<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reports - GLRS Admin</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸ“Š</text></svg>">
    <link rel="stylesheet" href="/admin/shared/styles.css">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.31/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script src="/admin/shared/firebase.js"></script>
    <script src="/admin/shared/auth.js"></script>
    <script src="/admin/shared/utils.js"></script>
    <script src="/admin/shared/state.js"></script>
    <script src="/admin/shared/navigation.js"></script>
    <script type="text/babel">
(function initPage() {
    if (!window.FIREBASE_READY || !window.auth || !window.db) {
        console.log('Waiting for Firebase to initialize...');
        setTimeout(initPage, 50);
        return;
    }
    const { useState, useEffect, useRef, useMemo, useCallback } = React;
    const { auth, db, storage, CURRENT_TENANT, logAudit } = window;

    const pirStats = analyticsData?.pirStats[pirId];
    const pirCheckIns = checkIns.filter(c => c.userId === pirId).sort((a, b) => {
        const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
        const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
        return dateB - dateA;
    });

    const moodChartRef = useRef(null);
    const cravingChartRef = useRef(null);
    const anxietyChartRef = useRef(null);
    const sleepChartRef = useRef(null);
    const chartInstances = useRef({});

    useEffect(() => {
        renderIndividualCharts();
        
        return () => {
            Object.values(chartInstances.current).forEach(chart => {
                if (chart) chart.destroy();
            });
        };
    }, [pirCheckIns]);

    const renderIndividualCharts = () => {
        const last30 = pirCheckIns.slice(0, 30).reverse();

        if (moodChartRef.current) {
            if (chartInstances.current.mood) chartInstances.current.mood.destroy();
            
            const ctx = moodChartRef.current.getContext('2d');
            chartInstances.current.mood = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: last30.map(c => formatDate(c.createdAt)),
                    datasets: [{
                        label: 'Morning Mood',
                        data: last30.map(c => c.morningData?.mood ?? null),
                        borderColor: '#0077CC',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 10 }
                    }
                }
            });
        }

        if (cravingChartRef.current) {
            if (chartInstances.current.craving) chartInstances.current.craving.destroy();
            
            const ctx = cravingChartRef.current.getContext('2d');
            chartInstances.current.craving = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: last30.map(c => formatDate(c.createdAt)),
                    datasets: [{
                        label: 'Cravings',
                        data: last30.map(c => c.morningData?.craving ?? null),
                        borderColor: '#f44336',
                        backgroundColor: 'rgba(244, 67, 54, 0.1)',
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 10 }
                    }
                }
            });
        }

        if (anxietyChartRef.current) {
            if (chartInstances.current.anxiety) chartInstances.current.anxiety.destroy();
            
            const ctx = anxietyChartRef.current.getContext('2d');
            chartInstances.current.anxiety = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: last30.map(c => formatDate(c.createdAt)),
                    datasets: [{
    label: 'Anxiety',
    data: last30.map(c => c.morningData?.anxietyLevel ?? null),
    borderColor: '#FF9800',
    backgroundColor: 'rgba(255, 152, 0, 0.1)',
    tension: 0.4,
    fill: true
}]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 10 }
                    }
                }
            });
        }

        if (sleepChartRef.current) {
            if (chartInstances.current.sleep) chartInstances.current.sleep.destroy();
            
            const ctx = sleepChartRef.current.getContext('2d');
            chartInstances.current.sleep = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: last30.map(c => formatDate(c.createdAt)),
                    datasets: [{
    label: 'Sleep Quality',
    data: last30.map(c => c.morningData?.sleepQuality ?? null),
    borderColor: '#9C27B0',
    backgroundColor: 'rgba(156, 39, 176, 0.1)',
    tension: 0.4,
    fill: true
}]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: true, max: 10 }
                    }
                }
            });
        }
    };

    const exportIndividualReport = () => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        let yPos = 20;
        
        // Title
        doc.setFontSize(20);
        doc.text(`Check-in Report: ${pirStats.userName}`, 14, yPos);
        yPos += 15;
        
        doc.setFontSize(10);
        doc.text(`Generated: ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}`, 14, yPos);
        yPos += 15;

        // Summary Stats
        doc.setFontSize(14);
        doc.text('Summary Statistics', 14, yPos);
        yPos += 5;

        const summaryData = [
            ['Metric', 'Lifetime', 'Last 30 Days'],
            ['Total Check-ins', pirStats.totalCheckIns, pirStats.last30.totalCheckIns],
            ['Average Mood', pirStats.avgMood, pirStats.last30.avgMood],
            ['Average Cravings', pirStats.avgCraving, pirStats.last30.avgCraving],
            ['Average Anxiety', pirStats.avgAnxiety, pirStats.last30.avgAnxiety],
            ['Average Sleep Quality', pirStats.avgSleep, pirStats.last30.avgSleep],
            ['Completion Rate', `${pirStats.completionRate}%`, `${pirStats.last30.completionRate}%`]
        ];

        doc.autoTable({
            startY: yPos,
            head: [summaryData[0]],
            body: summaryData.slice(1),
            theme: 'grid',
            headStyles: { fillColor: [102, 126, 234] }
        });

        // Recent Check-ins
        doc.addPage();
        yPos = 20;
        
        doc.setFontSize(14);
        doc.text('Recent Check-ins (Last 10)', 14, yPos);
        yPos += 5;

        const recentData = pirCheckIns.slice(0, 10).map(c => [
            formatDate(c.createdAt),
            c.morningData?.mood ?? '-',
            c.morningData?.craving ?? '-',
           c.morningData?.anxietyLevel ?? '-',
c.morningData?.sleepQuality ?? '-',
            c.eveningData?.overallDay ?? '-',
            c.completionStatus === 'complete' ? 'Yes' : 'No'
        ]);

        doc.autoTable({
            startY: yPos,
            head: [['Date', 'Mood', 'Craving', 'Anxiety', 'Sleep', 'Overall', 'Complete']],
            body: recentData,
            theme: 'grid',
            headStyles: { fillColor: [102, 126, 234] },
            styles: { fontSize: 9 }
        });

        // Gratitude & Challenges
        doc.addPage();
        yPos = 20;
        
        doc.setFontSize(14);
        doc.text('Recent Gratitude & Challenges', 14, yPos);
        yPos += 10;

        pirCheckIns.slice(0, 5).forEach((c, idx) => {
            if (yPos > 250) {
                doc.addPage();
                yPos = 20;
            }
            
            doc.setFontSize(12);
            doc.text(`${formatDate(c.createdAt)}`, 14, yPos);
            yPos += 7;
            
            doc.setFontSize(10);
            if (c.eveningData?.gratitude) {
                doc.text('Gratitude:', 14, yPos);
                yPos += 5;
                const gratitudeLines = doc.splitTextToSize(c.eveningData.gratitude, 180);
                doc.text(gratitudeLines, 20, yPos);
                yPos += gratitudeLines.length * 5 + 3;
            }
            
            if (c.eveningData?.challenges) {
                doc.text('Challenges:', 14, yPos);
                yPos += 5;
                const challengeLines = doc.splitTextToSize(c.eveningData.challenges, 180);
                doc.text(challengeLines, 20, yPos);
                yPos += challengeLines.length * 5 + 3;
            }
            
            yPos += 5;
        });

        doc.save(`${pirStats.userName.replace(/\s+/g, '_')}_Report_${new Date().toISOString().split('T')[0]}.pdf`);
    };

    if (!pirStats) return null;

    return (
        <div style={{ padding: '20px', animation: 'fadeIn 0.5s' }}>
            {/* Header */}
            <div style={{ 
                display: 'flex', 
                justifyContent: 'space-between', 
                alignItems: 'center',
                marginBottom: '30px'
            }}>
                <div>
                    <h2 style={{ margin: '0 0 10px 0', fontSize: '28px', color: '#333' }}>
                        {pirStats.userName} - Detailed Report
                    </h2>
                    <p style={{ margin: 0, color: '#666', fontSize: '14px' }}>
                        Comprehensive check-in analysis and trends
                    </p>
                </div>
                <div style={{ display: 'flex', gap: '10px' }}>
                    <button
                        onClick={exportIndividualReport}
                        style={{
                            padding: '12px 24px',
                            background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                            color: 'white',
                            border: 'none',
                            borderRadius: '10px',
                            cursor: 'pointer',
                            fontSize: '14px',
                            fontWeight: '600'
                        }}
                    >
                        Export PDF Report
                    </button>
                    <button
                        onClick={onClose}
                        style={{
                            padding: '12px 24px',
                            background: '#6c757d',
                            color: 'white',
                            border: 'none',
                            borderRadius: '10px',
                            cursor: 'pointer',
                            fontSize: '14px',
                            fontWeight: '600'
                        }}
                    >
                        Back to Analytics
                    </button>
                </div>
            </div>

            {/* Summary Cards */}
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px', marginBottom: '30px' }}>
                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #0077CC'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Total Check-ins</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#333' }}>{pirStats.totalCheckIns}</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.totalCheckIns}
                    </div>
                </div>

                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #00A86B'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Completion Rate</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#00A86B' }}>{pirStats.completionRate}%</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.completionRate}%
                    </div>
                </div>

                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #0077CC'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Avg Mood</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#0077CC' }}>{pirStats.avgMood}/10</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.avgMood}/10
                    </div>
                </div>

                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #f44336'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Avg Cravings</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#DC143C' }}>{pirStats.avgCraving}/10</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.avgCraving}/10
                    </div>
                </div>

                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #FF9800'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Avg Anxiety</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#FFA500' }}>{pirStats.avgAnxiety}/10</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.avgAnxiety}/10
                    </div>
                </div>

                <div style={{
                    background: 'white',
                    padding: '20px',
                    borderRadius: '12px',
                    boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                    borderLeft: '4px solid #9C27B0'
                }}>
                    <div style={{ fontSize: '13px', color: '#666', marginBottom: '8px' }}>Avg Sleep</div>
                    <div style={{ fontSize: '28px', fontWeight: 'bold', color: '#9C27B0' }}>{pirStats.avgSleep}/10</div>
                    <div style={{ fontSize: '12px', color: '#999', marginTop: '4px' }}>
                        Last 30 days: {pirStats.last30.avgSleep}/10
                    </div>
                </div>
            </div>

            {/* Charts */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '30px',
                marginBottom: '30px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <h3 style={{ margin: '0 0 25px 0', fontSize: '20px', color: '#333' }}>
                    Trend Analysis (Last 30 Check-ins)
                </h3>
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))', gap: '30px' }}>
                    <div>
                        <h4 style={{ margin: '0 0 15px 0', fontSize: '16px', color: '#666' }}>Mood Trend</h4>
                        <div style={{ height: '250px' }}>
                            <canvas ref={moodChartRef}></canvas>
                        </div>
                    </div>
                    <div>
                        <h4 style={{ margin: '0 0 15px 0', fontSize: '16px', color: '#666' }}>Craving Intensity</h4>
                        <div style={{ height: '250px' }}>
                            <canvas ref={cravingChartRef}></canvas>
                        </div>
                    </div>
                    <div>
                        <h4 style={{ margin: '0 0 15px 0', fontSize: '16px', color: '#666' }}>Anxiety Levels</h4>
                        <div style={{ height: '250px' }}>
                            <canvas ref={anxietyChartRef}></canvas>
                        </div>
                    </div>
                    <div>
                        <h4 style={{ margin: '0 0 15px 0', fontSize: '16px', color: '#666' }}>Sleep Quality</h4>
                        <div style={{ height: '250px' }}>
                            <canvas ref={sleepChartRef}></canvas>
                        </div>
                    </div>
                </div>
            </div>

            {/* Recent Check-ins Table */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '30px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <h3 style={{ margin: '0 0 20px 0', fontSize: '20px', color: '#333' }}>
                    Recent Check-ins (Last 10)
                </h3>
                <div style={{ overflowX: 'auto' }}>
                    <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                        <thead style={{ background: '#f8f9fa' }}>
                            <tr>
                                <th style={{ padding: '12px', textAlign: 'left', fontWeight: '600', color: '#333', fontSize: '13px' }}>Date</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Mood</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Craving</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Anxiety</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Sleep</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Overall</th>
                                <th style={{ padding: '12px', textAlign: 'center', fontWeight: '600', color: '#333', fontSize: '13px' }}>Complete</th>
                            </tr>
                        </thead>
                        <tbody>
                            {pirCheckIns.slice(0, 10).map(checkIn => (
                                <tr key={checkIn.id} style={{ borderBottom: '1px solid #f0f0f0' }}>
                                    <td style={{ padding: '12px', fontSize: '13px', color: '#666' }}>
                                        {formatDate(checkIn.createdAt)}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center', fontSize: '14px', fontWeight: '600', color: '#0077CC' }}>
                                        {checkIn.morningData?.mood ?? '-'}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center', fontSize: '14px', fontWeight: '600', color: '#DC143C' }}>
                                        {checkIn.morningData?.craving ?? '-'}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center', fontSize: '14px', fontWeight: '600', color: '#FFA500' }}>
                                        {checkIn.eveningData?.anxiety ?? '-'}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center', fontSize: '14px', fontWeight: '600', color: '#9C27B0' }}>
                                        {checkIn.eveningData?.sleepQuality ?? '-'}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center', fontSize: '14px', fontWeight: '600', color: '#4682B4' }}>
                                        {checkIn.eveningData?.overallDay ?? '-'}
                                    </td>
                                    <td style={{ padding: '12px', textAlign: 'center' }}>
                                        <span style={{
                                            padding: '4px 10px',
                                            borderRadius: '12px',
                                            fontSize: '11px',
                                            fontWeight: '600',
                                            background: checkIn.completionStatus === 'complete' ? '#d4edda' : '#f8d7da',
                                            color: checkIn.completionStatus === 'complete' ? '#155724' : '#721c24'
                                        }}>
                                            {checkIn.completionStatus === 'complete' ? 'Yes' : 'No'}
                                        </span>
                                    </td>
                                </tr>
                            ))}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    );
}

// FULLY ENHANCED FeedbackView with All Features
function FeedbackView({ searchQuery, user }) {
    const [feedbacks, setFeedbacks] = useState([]);
    const [filteredFeedbacks, setFilteredFeedbacks] = useState([]);
    const [loading, setLoading] = useState(true);
    const [currentPage, setCurrentPage] = useState(1);
    const [filterStatus, setFilterStatus] = useState('all');
    const [filterType, setFilterType] = useState('all');
    const [filterSentiment, setFilterSentiment] = useState('all');
    const [selectedFeedback, setSelectedFeedback] = useState(null);
    const [selectedFeedbacks, setSelectedFeedbacks] = useState(new Set());
    const [stats, setStats] = useState({
        total: 0,
        pending: 0,
        avgRating: 0,
        responseRate: 0
    });
    const itemsPerPage = 20;

    useEffect(() => {
        loadFeedbacks();
    }, []);

    useEffect(() => {
        filterFeedbacks();
        calculateStats();
    }, [feedbacks, filterStatus, filterType, filterSentiment, searchQuery]);

    const analyzeSentiment = (feedback) => {
        const text = (feedback.message + ' ' + feedback.subject).toLowerCase();
        const positiveWords = ['great', 'excellent', 'amazing', 'love', 'perfect', 'fantastic', 'wonderful', 'helpful', 'thank'];
        const negativeWords = ['bad', 'terrible', 'awful', 'hate', 'worst', 'horrible', 'disappointed', 'frustrated', 'angry', 'useless'];
        
        let score = 0;
        positiveWords.forEach(word => { if (text.includes(word)) score++; });
        negativeWords.forEach(word => { if (text.includes(word)) score--; });
        
        if (score > 1) return 'positive';
        if (score < -1) return 'negative';
        return 'neutral';
    };

    const loadFeedbacks = async () => {
        try {
            const feedbacksSnap = await db.collection('feedback')
                .orderBy('createdAt', 'desc')
                .get();
            
            const feedbacksData = [];
            const userIds = new Set();
            
            feedbacksSnap.forEach(doc => {
                const feedback = { id: doc.id, ...doc.data() };
                feedback.sentiment = analyzeSentiment(feedback);
                feedbacksData.push(feedback);
                if (feedback.userId) userIds.add(feedback.userId);
            });
            
            if (userIds.size > 0) {
                const userResults = await batchQuery('users',
                    firebase.firestore.FieldPath.documentId(),
                    Array.from(userIds)
                );
                
                const userMap = {};
                userResults.forEach(user => {
                    userMap[user.id] = user.displayName || user.email;
                });
                
                feedbacksData.forEach(feedback => {
                    feedback.userName = userMap[feedback.userId] || 'Anonymous';
                });
            }
            
            setFeedbacks(feedbacksData);
            setFilteredFeedbacks(feedbacksData);
        } catch (error) {
            console.error('Error loading feedback:', error);
            alert('Failed to load feedback');
        } finally {
            setLoading(false);
        }
    };

    const calculateStats = () => {
        const total = feedbacks.length;
        const pending = feedbacks.filter(f => !f.reviewed).length;
        const ratings = feedbacks.filter(f => f.rating).map(f => f.rating);
        const avgRating = ratings.length > 0 ? (ratings.reduce((a, b) => a + b, 0) / ratings.length).toFixed(1) : 0;
        const responded = feedbacks.filter(f => f.response).length;
        const responseRate = total > 0 ? Math.round((responded / total) * 100) : 0;
        
        setStats({ total, pending, avgRating, responseRate });
    };

    const filterFeedbacks = () => {
        let filtered = feedbacks;
        
        if (filterStatus !== 'all') {
            filtered = filtered.filter(feedback => 
                filterStatus === 'reviewed' ? feedback.reviewed : !feedback.reviewed
            );
        }
        
        if (filterType !== 'all') {
            filtered = filtered.filter(feedback => feedback.type === filterType);
        }
        
        if (filterSentiment !== 'all') {
            filtered = filtered.filter(feedback => feedback.sentiment === filterSentiment);
        }
        
        if (searchQuery) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter(feedback =>
                feedback.userName?.toLowerCase().includes(query) ||
                feedback.subject?.toLowerCase().includes(query) ||
                feedback.message?.toLowerCase().includes(query)
            );
        }
        
        setFilteredFeedbacks(filtered);
        setCurrentPage(1);
    };

    const quickFilter = (type) => {
        if (type === 'urgent') {
            setFilterType('complaint');
            setFilterStatus('pending');
        } else if (type === 'high-priority') {
            setFilterSentiment('negative');
            setFilterStatus('pending');
        } else if (type === 'needs-response') {
            setFilterStatus('pending');
        }
    };

    const handleSelectAll = () => {
        if (selectedFeedbacks.size === paginatedFeedbacks.length) {
            setSelectedFeedbacks(new Set());
        } else {
            setSelectedFeedbacks(new Set(paginatedFeedbacks.map(f => f.id)));
        }
    };

    const handleSelectFeedback = (feedbackId) => {
        const newSelected = new Set(selectedFeedbacks);
        if (newSelected.has(feedbackId)) {
            newSelected.delete(feedbackId);
        } else {
            newSelected.add(feedbackId);
        }
        setSelectedFeedbacks(newSelected);
    };

    const handleBulkMarkReviewed = async () => {
        try {
            const batch = db.batch();
            selectedFeedbacks.forEach(feedbackId => {
                const feedbackRef = db.collection('feedback').doc(feedbackId);
                batch.update(feedbackRef, {
                    reviewed: true,
                    reviewedBy: user.uid,
                    reviewedAt: firebase.firestore.FieldValue.serverTimestamp()
                });
            });
            
            await batch.commit();
            
            setFeedbacks(prev => prev.map(f => 
                selectedFeedbacks.has(f.id) ? { ...f, reviewed: true } : f
            ));
            setSelectedFeedbacks(new Set());
            alert(`Marked ${selectedFeedbacks.size} feedbacks as reviewed`);
        } catch (error) {
            console.error('Error bulk updating:', error);
            alert('Failed to update feedbacks');
        }
    };

    const handleMarkReviewed = async (feedbackId, reviewed = true) => {
        try {
            await db.collection('feedback').doc(feedbackId).update({
                reviewed: reviewed,
                reviewedBy: user.uid,
                reviewedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            
            setFeedbacks(prev => prev.map(f => 
                f.id === feedbackId ? { ...f, reviewed } : f
            ));
            
            alert('Feedback marked as ' + (reviewed ? 'reviewed' : 'unreviewed'));
        } catch (error) {
            console.error('Error updating feedback:', error);
            alert('Failed to update feedback');
        }
    };

    const handleRespond = async (feedbackId, response) => {
        try {
            await db.collection('feedback').doc(feedbackId).update({
                response: response,
                respondedBy: user.uid,
                respondedAt: firebase.firestore.FieldValue.serverTimestamp(),
                reviewed: true
            });
            
            setFeedbacks(prev => prev.map(f => 
                f.id === feedbackId ? { ...f, response, reviewed: true } : f
            ));
            
            alert('Response sent successfully');
        } catch (error) {
            console.error('Error responding to feedback:', error);
            alert('Failed to send response');
        }
    };

    const handleDelete = async (feedbackId) => {
        if (!confirm('Are you sure you want to delete this feedback?')) return;
        
        try {
            await db.collection('feedback').doc(feedbackId).delete();
            setFeedbacks(prev => prev.filter(f => f.id !== feedbackId));
            alert('Feedback deleted');
        } catch (error) {
            console.error('Error deleting feedback:', error);
            alert('Failed to delete feedback');
        }
    };

    const renderStars = (rating) => {
        if (!rating) return '-';
        return (
            <div style={{ display: 'flex', gap: '2px' }}>
                {[1, 2, 3, 4, 5].map(star => (
                    <span key={star} style={{ 
                        color: star <= rating ? '#FFD700' : '#ddd',
                        fontSize: '16px'
                    }}>
                        â˜…
                    </span>
                ))}
            </div>
        );
    };

    const getSentimentColor = (sentiment) => {
        if (sentiment === 'positive') return '#00A86B';
        if (sentiment === 'negative') return '#f44336';
        return '#9E9E9E';
    };

    const paginatedFeedbacks = useMemo(() => {
        const start = (currentPage - 1) * itemsPerPage;
        const end = start + itemsPerPage;
        return filteredFeedbacks.slice(start, end);
    }, [filteredFeedbacks, currentPage]);

    const totalPages = Math.ceil(filteredFeedbacks.length / itemsPerPage);

    const handleExport = (format) => {
        const exportData = filteredFeedbacks.map(feedback => ({
            user: feedback.userName,
            type: feedback.type,
            subject: feedback.subject,
            message: feedback.message,
            rating: feedback.rating || 'N/A',
            sentiment: feedback.sentiment,
            status: feedback.reviewed ? 'Reviewed' : 'Pending',
            createdAt: formatDate(feedback.createdAt),
            response: feedback.response || 'No response yet'
        }));

        if (format === 'json') {
            exportToJSON(exportData, 'feedback');
        } else if (format === 'csv') {
            exportToCSV(exportData, 'feedback');
        } else if (format === 'pdf') {
            exportToPDF(exportData, 'Feedback Report');
        }
    };

    if (loading) {
        return (
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                minHeight: '400px',
                gap: '20px'
            }}>
                <div style={{
                    width: '60px',
                    height: '60px',
                    border: '4px solid #f3f3f3',
                    borderTop: '4px solid #0077CC',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite'
                }}></div>
                <p style={{ color: '#666' }}>Loading feedback...</p>
            </div>
        );
    }

    return (
        <div style={{ padding: '20px', animation: 'fadeIn 0.5s' }}>
            {/* Stats Cards */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fit, minmax(240px, 1fr))',
                gap: '20px',
                marginBottom: '30px'
            }}>
                <div style={{
                    background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(102, 126, 234, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Total Feedback</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.total}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>All time</div>
                </div>

                <div style={{
                    background: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(240, 147, 251, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Pending Reviews</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.pending}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>Awaiting action</div>
                </div>

                <div style={{
                    background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(79, 172, 254, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Average Rating</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.avgRating}/5
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>From rated feedback</div>
                </div>

                <div style={{
                    background: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(250, 112, 154, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Response Rate</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.responseRate}%
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>Responded to</div>
                </div>
            </div>

            {/* Quick Filters */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '15px 20px',
                marginBottom: '20px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)',
                display: 'flex',
                gap: '10px',
                flexWrap: 'wrap',
                alignItems: 'center'
            }}>
                <span style={{ fontWeight: '600', color: '#333', marginRight: '10px' }}>Quick Filters:</span>
                <button
                    onClick={() => quickFilter('urgent')}
                    style={{
                        padding: '8px 16px',
                        background: 'linear-gradient(135deg, #f44336 0%, #e53935 100%)',
                        color: 'white',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        fontSize: '13px',
                        fontWeight: '500',
                        transition: 'transform 0.2s'
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-2px)'}
                    onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    Urgent Complaints
                </button>
                <button
                    onClick={() => quickFilter('high-priority')}
                    style={{
                        padding: '8px 16px',
                        background: 'linear-gradient(135deg, #FF9800 0%, #F57C00 100%)',
                        color: 'white',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        fontSize: '13px',
                        fontWeight: '500',
                        transition: 'transform 0.2s'
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-2px)'}
                    onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    High Priority
                </button>
                <button
                    onClick={() => quickFilter('needs-response')}
                    style={{
                        padding: '8px 16px',
                        background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                        color: 'white',
                        border: 'none',
                        borderRadius: '8px',
                        cursor: 'pointer',
                        fontSize: '13px',
                        fontWeight: '500',
                        transition: 'transform 0.2s'
                    }}
                    onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-2px)'}
                    onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    Needs Response
                </button>
            </div>

            {/* Filters and Actions Bar */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '20px',
                marginBottom: '20px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: '15px' }}>
                    <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                        <select 
                            value={filterStatus}
                            onChange={(e) => setFilterStatus(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Status</option>
                            <option value="pending">Pending Review</option>
                            <option value="reviewed">Reviewed</option>
                        </select>
                        
                        <select 
                            value={filterType}
                            onChange={(e) => setFilterType(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Types</option>
                            <option value="bug">Bug Report</option>
                            <option value="feature">Feature Request</option>
                            <option value="general">General Feedback</option>
                            <option value="complaint">Complaint</option>
                            <option value="praise">Praise</option>
                        </select>

                        <select 
                            value={filterSentiment}
                            onChange={(e) => setFilterSentiment(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Sentiments</option>
                            <option value="positive">Positive</option>
                            <option value="neutral">Neutral</option>
                            <option value="negative">Negative</option>
                        </select>
                    </div>
                    
                    <div style={{ display: 'flex', gap: '10px' }}>
                        {selectedFeedbacks.size > 0 && (
                            <button 
                                onClick={handleBulkMarkReviewed}
                                style={{
                                    padding: '10px 16px',
                                    background: 'linear-gradient(135deg, #00A86B 0%, #008554 100%)',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500'
                                }}
                            >
                                Mark {selectedFeedbacks.size} as Reviewed
                            </button>
                        )}
                        <button 
                            onClick={() => handleExport('csv')}
                            style={{
                                padding: '10px 16px',
                                background: '#6c757d',
                                color: 'white',
                                border: 'none',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            Export CSV
                        </button>
                    </div>
                </div>
            </div>
            
            {/* Enhanced Table */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                overflow: 'hidden',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                        <tr style={{ background: '#f8f9fa', borderBottom: '2px solid #e9ecef' }}>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>
                                <input 
                                    type="checkbox"
                                    checked={selectedFeedbacks.size === paginatedFeedbacks.length && paginatedFeedbacks.length > 0}
                                    onChange={handleSelectAll}
                                    style={{ cursor: 'pointer', width: '16px', height: '16px' }}
                                />
                            </th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>User</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Type</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Subject</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Rating</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Sentiment</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Status</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Date</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {paginatedFeedbacks.map(feedback => (
                            <tr key={feedback.id} style={{
                                borderBottom: '1px solid #f0f0f0',
                                transition: 'all 0.2s',
                                background: selectedFeedbacks.has(feedback.id) ? '#f0f4ff' : 'white'
                            }}
                            onMouseEnter={(e) => {
                                if (!selectedFeedbacks.has(feedback.id)) {
                                    e.currentTarget.style.background = '#f8f9fa';
                                }
                            }}
                            onMouseLeave={(e) => {
                                if (!selectedFeedbacks.has(feedback.id)) {
                                    e.currentTarget.style.background = 'white';
                                }
                            }}
                            >
                                <td style={{ padding: '15px' }}>
                                    <input 
                                        type="checkbox"
                                        checked={selectedFeedbacks.has(feedback.id)}
                                        onChange={() => handleSelectFeedback(feedback.id)}
                                        style={{ cursor: 'pointer', width: '16px', height: '16px' }}
                                    />
                                </td>
                                <td style={{ padding: '15px', fontWeight: '500', color: '#333' }}>
                                    {feedback.userName}
                                </td>
                                <td style={{ padding: '15px' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '12px',
                                        fontWeight: '500',
                                        background: '#e3f2fd',
                                        color: '#1976d2'
                                    }}>
                                        {feedback.type}
                                    </span>
                                </td>
                                <td style={{ padding: '15px', color: '#666', maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                    {feedback.subject}
                                </td>
                                <td style={{ padding: '15px' }}>{renderStars(feedback.rating)}</td>
                                <td style={{ padding: '15px' }}>
                                    <div style={{
                                        width: '10px',
                                        height: '10px',
                                        borderRadius: '50%',
                                        background: getSentimentColor(feedback.sentiment),
                                        display: 'inline-block'
                                    }}></div>
                                </td>
                                <td style={{ padding: '15px' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '12px',
                                        fontWeight: '500',
                                        background: feedback.reviewed ? '#d4edda' : '#fff3cd',
                                        color: feedback.reviewed ? '#155724' : '#856404'
                                    }}>
                                        {feedback.reviewed ? 'Reviewed' : 'Pending'}
                                    </span>
                                </td>
                                <td style={{ padding: '15px', color: '#666' }}>{formatDate(feedback.createdAt)}</td>
                                <td style={{ padding: '15px' }}>
                                    <button 
                                        onClick={() => setSelectedFeedback(feedback)}
                                        style={{
                                            padding: '6px 12px',
                                            background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                                            color: 'white',
                                            border: 'none',
                                            borderRadius: '6px',
                                            cursor: 'pointer',
                                            fontSize: '13px',
                                            fontWeight: '500'
                                        }}
                                    >
                                        View
                                    </button>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
                
                {filteredFeedbacks.length === 0 && (
                    <div style={{
                        padding: '60px 20px',
                        textAlign: 'center',
                        color: '#999'
                    }}>
                        <div style={{ fontSize: '48px', marginBottom: '15px' }}>ðŸ“</div>
                        <div style={{ fontSize: '18px', fontWeight: '500', marginBottom: '8px' }}>
                            No feedback found
                        </div>
                        <div style={{ fontSize: '14px' }}>
                            {searchQuery ? 'Try adjusting your search terms' : 'Feedback will appear here when submitted'}
                        </div>
                    </div>
                )}
            </div>
            
            {totalPages > 1 && (
                <div style={{ marginTop: '20px' }}>
                    <Pagination 
                        currentPage={currentPage}
                        totalPages={totalPages}
                        onPageChange={setCurrentPage}
                    />
                </div>
            )}
            
            {selectedFeedback && (
                <FeedbackDetailModal 
                    feedback={selectedFeedback}
                    onClose={() => setSelectedFeedback(null)}
                    onRespond={handleRespond}
                    onMarkReviewed={handleMarkReviewed}
                    getSentimentColor={getSentimentColor}
                    renderStars={renderStars}
                />
            )}
        </div>
    );
}

// Enhanced Feedback Detail Modal
function FeedbackDetailModal({ feedback, onClose, onRespond, onMarkReviewed, getSentimentColor, renderStars }) {
    const [response, setResponse] = useState(feedback.response || '');
    const [submitting, setSubmitting] = useState(false);

    const handleSubmit = async () => {
        if (!response.trim()) {
            alert('Please enter a response');
            return;
        }
        
        setSubmitting(true);
        await onRespond(feedback.id, response);
        setSubmitting(false);
        onClose();
    };

    return (
        <div style={{
            position: 'fixed',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            background: 'rgba(0, 0, 0, 0.5)',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            zIndex: 1000,
            padding: '20px',
            animation: 'fadeIn 0.2s'
        }}>
            <div style={{
                background: 'white',
                borderRadius: '20px',
                maxWidth: '700px',
                width: '100%',
                maxHeight: '90vh',
                overflow: 'auto',
                boxShadow: '0 20px 60px rgba(0, 0, 0, 0.3)',
                animation: 'slideUp 0.3s'
            }}>
                {/* Header */}
                <div style={{
                    background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                    padding: '25px 30px',
                    borderRadius: '20px 20px 0 0',
                    color: 'white',
                    position: 'sticky',
                    top: 0,
                    zIndex: 1
                }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <h2 style={{ margin: 0, fontSize: '24px' }}>Feedback Details</h2>
                        <button 
                            onClick={onClose}
                            style={{
                                background: 'rgba(255,255,255,0.2)',
                                border: 'none',
                                color: 'white',
                                fontSize: '24px',
                                width: '36px',
                                height: '36px',
                                borderRadius: '50%',
                                cursor: 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                transition: 'background 0.2s'
                            }}
                            onMouseEnter={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.3)'}
                            onMouseLeave={(e) => e.currentTarget.style.background = 'rgba(255,255,255,0.2)'}
                        >
                            Ã—
                        </button>
                    </div>
                </div>

                {/* Content */}
                <div style={{ padding: '30px' }}>
                    {/* Info Grid */}
                    <div style={{
                        display: 'grid',
                        gridTemplateColumns: 'repeat(2, 1fr)',
                        gap: '20px',
                        marginBottom: '25px'
                    }}>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>User</div>
                            <div style={{ fontSize: '16px', fontWeight: '500', color: '#333' }}>
                                {feedback.userName}
                            </div>
                        </div>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>Type</div>
                            <div style={{ fontSize: '16px', fontWeight: '500', color: '#333' }}>
                                {feedback.type}
                            </div>
                        </div>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>Rating</div>
                            {renderStars(feedback.rating)}
                        </div>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>Sentiment</div>
                            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                                <div style={{
                                    width: '12px',
                                    height: '12px',
                                    borderRadius: '50%',
                                    background: getSentimentColor(feedback.sentiment)
                                }}></div>
                                <span style={{ textTransform: 'capitalize' }}>{feedback.sentiment}</span>
                            </div>
                        </div>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>Date</div>
                            <div style={{ fontSize: '16px', fontWeight: '500', color: '#333' }}>
                                {formatDate(feedback.createdAt)}
                            </div>
                        </div>
                        <div>
                            <div style={{ fontSize: '12px', color: '#999', marginBottom: '5px' }}>Status</div>
                            <span style={{
                                padding: '4px 12px',
                                borderRadius: '20px',
                                fontSize: '12px',
                                fontWeight: '500',
                                background: feedback.reviewed ? '#d4edda' : '#fff3cd',
                                color: feedback.reviewed ? '#155724' : '#856404'
                            }}>
                                {feedback.reviewed ? 'Reviewed' : 'Pending'}
                            </span>
                        </div>
                    </div>

                    {/* Subject */}
                    <div style={{ marginBottom: '20px' }}>
                        <div style={{ fontSize: '14px', fontWeight: '600', color: '#333', marginBottom: '8px' }}>
                            Subject
                        </div>
                        <div style={{
                            padding: '15px',
                            background: '#f8f9fa',
                            borderRadius: '10px',
                            color: '#666'
                        }}>
                            {feedback.subject}
                        </div>
                    </div>

                    {/* Message */}
                    <div style={{ marginBottom: '25px' }}>
                        <div style={{ fontSize: '14px', fontWeight: '600', color: '#333', marginBottom: '8px' }}>
                            Message
                        </div>
                        <div style={{
                            padding: '15px',
                            background: '#f8f9fa',
                            borderRadius: '10px',
                            color: '#666',
                            lineHeight: '1.6',
                            whiteSpace: 'pre-wrap'
                        }}>
                            {feedback.message}
                        </div>
                    </div>

                    {/* Response Section */}
                    <div style={{ marginBottom: '20px' }}>
                        <div style={{ fontSize: '14px', fontWeight: '600', color: '#333', marginBottom: '8px' }}>
                            {feedback.response ? 'Your Response' : 'Add Response'}
                        </div>
                        <textarea
                            value={response}
                            onChange={(e) => setResponse(e.target.value)}
                            placeholder="Type your response here..."
                            style={{
                                width: '100%',
                                minHeight: '120px',
                                padding: '15px',
                                border: '2px solid #e0e0e0',
                                borderRadius: '10px',
                                fontSize: '14px',
                                fontFamily: 'inherit',
                                resize: 'vertical',
                                transition: 'border-color 0.2s'
                            }}
                            onFocus={(e) => e.currentTarget.style.borderColor = '#0077CC'}
                            onBlur={(e) => e.currentTarget.style.borderColor = '#e0e0e0'}
                        />
                    </div>

                    {/* Actions */}
                    <div style={{ display: 'flex', gap: '10px', justifyContent: 'flex-end' }}>
                        {!feedback.reviewed && (
                            <button
                                onClick={() => {
                                    onMarkReviewed(feedback.id, true);
                                    onClose();
                                }}
                                style={{
                                    padding: '12px 24px',
                                    background: '#6c757d',
                                    color: 'white',
                                    border: 'none',
                                    borderRadius: '8px',
                                    cursor: 'pointer',
                                    fontSize: '14px',
                                    fontWeight: '500',
                                    transition: 'background 0.2s'
                                }}
                                onMouseEnter={(e) => e.currentTarget.style.background = '#5a6268'}
                                onMouseLeave={(e) => e.currentTarget.style.background = '#6c757d'}
                            >
                                Mark as Reviewed
                            </button>
                        )}
                        <button
                            onClick={handleSubmit}
                            disabled={submitting || !response.trim()}
                            style={{
                                padding: '12px 24px',
                                background: submitting || !response.trim() 
                                    ? '#ccc' 
                                    : 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                                color: 'white',
                                border: 'none',
                                borderRadius: '8px',
                                cursor: submitting || !response.trim() ? 'not-allowed' : 'pointer',
                                fontSize: '14px',
                                fontWeight: '500',
                                transition: 'transform 0.2s'
                            }}
                            onMouseEnter={(e) => {
                                if (!submitting && response.trim()) {
                                    e.currentTarget.style.transform = 'translateY(-2px)';
                                }
                            }}
                            onMouseLeave={(e) => {
                                e.currentTarget.style.transform = 'translateY(0)';
                            }}
                        >
                            {submitting ? 'Sending...' : 'Send Response'}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    );
}

  // ==========================================
// ALERTS VIEW - FIREBASE EXTENSION VERSION
// ==========================================
function AlertsView({ searchQuery, user }) {
    const [alerts, setAlerts] = useState([]);
    const [filteredAlerts, setFilteredAlerts] = useState([]);
    const [loading, setLoading] = useState(true);
    const [currentPage, setCurrentPage] = useState(1);
    const [filterType, setFilterType] = useState('all');
    const [filterPriority, setFilterPriority] = useState('all');
    const [filterResolved, setFilterResolved] = useState('unresolved');
    const [selectedAlert, setSelectedAlert] = useState(null);
    const [stats, setStats] = useState({
        total: 0,
        active: 0,
        critical: 0,
        // Type-specific breakdowns
        sos: { count: 0, avgResponseTime: 0 },
        missedCheckin: { count: 0, avgResponseTime: 0 },
        highCraving: { count: 0, avgResponseTime: 0 },
        customThreshold: { count: 0 }
    });
    const [frequencyData, setFrequencyData] = useState([]);
    const frequencyChartRef = useRef(null);
    const chartInstance = useRef(null);
    const itemsPerPage = 20;

    useEffect(() => {
        loadAlerts();
        
        // Real-time SOS listener
        const unsubscribe = db.collection('alerts')
            .where('type', '==', 'sos')
            .where('status', '==', 'active')
            .onSnapshot(snapshot => {
                snapshot.docChanges().forEach(change => {
                    if (change.type === 'added') {
                        const alert = { id: change.doc.id, ...change.doc.data() };
                        
                        // Only process NEW alerts (created in last 10 seconds)
                        const alertTime = alert.createdAt?.toDate ? alert.createdAt.toDate() : new Date(alert.createdAt);
                        const now = new Date();
                        const secondsAgo = (now - alertTime) / 1000;
                        
                        if (secondsAgo < 10) {
                            console.log('ðŸš¨ NEW SOS ALERT DETECTED:', alert.id);
                            handleNewSOSAlert(alert);
                        }
                    }
                });
            });
        
        return () => {
            unsubscribe();
            if (chartInstance.current) {
                chartInstance.current.destroy();
            }
        };
    }, []);

    useEffect(() => {
        filterAlerts();
        calculateStats();
        prepareFrequencyData();
    }, [alerts, filterType, filterPriority, filterResolved, searchQuery]);

    useEffect(() => {
        if (frequencyData.length > 0) {
            renderFrequencyChart();
        }
    }, [frequencyData]);

    // ==========================================
    // ENHANCED SOS HANDLER - FIREBASE EXTENSION VERSION
    // ==========================================
    const handleNewSOSAlert = async (alert) => {
        try {
            console.log('ðŸš¨ Processing SOS alert for notifications...');
            
            // Show browser notification first (instant feedback)
            showBrowserNotification(alert);
            
            // Get PIR data
            const pirDoc = await db.collection('users').doc(alert.userId).get();
            if (!pirDoc.exists) {
                console.error('âŒ PIR not found:', alert.userId);
                return;
            }
            
            const pirData = pirDoc.data();
            console.log('ðŸ‘¤ PIR data loaded:', pirData.email);
            
            // Check if this PIR is assigned to current coach
            if (pirData.assignedCoach !== user.uid) {
                console.log('âš ï¸ This PIR is not assigned to current coach - skipping email');
                return;
            }
            
            // Get current coach's email
            const coachDoc = await db.collection('users').doc(user.uid).get();
            const coachData = coachDoc.data();
            const coachEmail = coachData.email;
            
            console.log('ðŸ“§ Sending SOS email via Firebase Extension to:', coachEmail);
            
            // Send email using Firebase Extension (NEW METHOD)
            await db.collection('mail').add({
                to: [coachEmail],
                message: {
                    subject: 'ðŸš¨ URGENT: SOS Alert from ' + (pirData.displayName || pirData.firstName || pirData.email),
                    html: `
                        <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
                            <div style="background: #dc2626; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                                <h1 style="margin: 0; font-size: 24px;">ðŸš¨ SOS ALERT</h1>
                            </div>
                            
                            <div style="background: #f9fafb; padding: 20px; border: 1px solid #e5e7eb;">
                                <h2 style="color: #dc2626; margin-top: 0;">Person in Recovery Needs Help</h2>
                                
                                <div style="background: white; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                    <p style="margin: 5px 0;"><strong>Name:</strong> ${pirData.displayName || pirData.firstName || 'Not provided'}</p>
                                    <p style="margin: 5px 0;"><strong>Email:</strong> ${pirData.email}</p>
                                    <p style="margin: 5px 0;"><strong>Phone:</strong> ${pirData.phone || 'Not provided'}</p>
                                    <p style="margin: 5px 0;"><strong>Time:</strong> ${new Date(alert.timestamp?.toDate ? alert.timestamp.toDate() : Date.now()).toLocaleString()}</p>
                                </div>
                                
                                ${alert.message ? `
                                <div style="background: #fef2f2; padding: 15px; border-left: 4px solid #dc2626; margin: 15px 0;">
                                    <p style="margin: 0;"><strong>Message:</strong></p>
                                    <p style="margin: 10px 0 0 0;">${alert.message}</p>
                                </div>
                                ` : ''}
                                
                                <div style="background: #fffbeb; padding: 15px; border-radius: 8px; margin: 15px 0;">
                                    <p style="margin: 0; color: #92400e;">
                                        <strong>âš ï¸ Action Required:</strong> Please contact this person immediately.
                                    </p>
                                </div>
                                
                                <div style="text-align: center; margin-top: 20px;">
                                    <a href="app.glrecoveryservices.com/admin.html" 
                                       style="background: #2563eb; color: white; padding: 12px 24px; text-decoration: none; border-radius: 6px; display: inline-block;">
                                        View in Coach Portal
                                    </a>
                                </div>
                            </div>
                            
                            <div style="background: #f3f4f6; padding: 15px; text-align: center; font-size: 12px; color: #6b7280; border-radius: 0 0 8px 8px;">
                                <p style="margin: 0;">Guiding Light Recovery Services</p>
                                <p style="margin: 5px 0 0 0;">Automated alert system</p>
                            </div>
                        </div>
                    `,
                    text: `
ðŸš¨ SOS ALERT - ${pirData.displayName || pirData.firstName || pirData.email}

A person in recovery has triggered an SOS alert and needs immediate assistance.

Name: ${pirData.displayName || pirData.firstName || 'Not provided'}
Email: ${pirData.email}
Phone: ${pirData.phone || 'Not provided'}
Time: ${new Date(alert.timestamp?.toDate ? alert.timestamp.toDate() : Date.now()).toLocaleString()}
${alert.message ? `\nMessage: ${alert.message}` : ''}

âš ï¸ Please contact this person immediately.

View details: app.glrecoveryservices.com/admin.html

---
Guiding Light Recovery Services
Automated alert system
                    `
                }
            });
            
            console.log('âœ… SOS email queued successfully!');
            
            // Update alert to mark email was sent
            await db.collection('alerts').doc(alert.id).update({
                emailSent: true,
                emailSentAt: firebase.firestore.FieldValue.serverTimestamp(),
                emailSentTo: coachEmail
            });
            
            // Show success notification
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ðŸš¨ SOS EMAIL SENT', {
                    body: `Emergency alert from ${pirData.displayName || pirData.email}\n\nâœ“ Email notification sent to your inbox`,
                    icon: '/favicon.ico',
                    requireInteraction: true,
                    tag: 'sos-email-sent'
                });
            }
            
            // Create in-app notification
            await createInAppNotification(alert, pirData);
            
            console.log('âœ… SOS alert processing complete');
            
        } catch (error) {
            console.error('âŒ Error handling SOS alert:', error);
            
            // Still show notification about the SOS even if email failed
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification('ðŸš¨ SOS ALERT - Email Failed', {
                    body: `Emergency alert detected but email failed to send.\n\nError: ${error.message}\n\nCheck Alerts tab immediately!`,
                    icon: '/favicon.ico',
                    requireInteraction: true,
                    tag: 'sos-email-failed'
                });
            }
        }
    };

    // Helper: Show browser notification
    const showBrowserNotification = (alert) => {
        if ('Notification' in window) {
            if (Notification.permission === 'granted') {
                new Notification('ðŸš¨ SOS ALERT', {
                    body: `Emergency alert detected - Processing...`,
                    icon: '/favicon.ico',
                    requireInteraction: true,
                    tag: 'sos-alert'
                });
            } else if (Notification.permission === 'default') {
                Notification.requestPermission();
            }
        }
    };

    // Helper: Create in-app notification (with preference checking)
    const createInAppNotification = async (alert, pirData) => {
        await createNotificationWithPreferences({
            type: 'sos',
            title: 'ðŸš¨ EMERGENCY: SOS Alert',
            message: `${pirData.displayName || pirData.email} has triggered an SOS alert`,
            recipientId: user.uid,
            relatedId: alert.id,
            urgent: true,
            read: false
        }, 'sos');
    };

    const loadAlerts = async () => {
        try {
            const alertsSnap = await db.collection('alerts')
                .orderBy('createdAt', 'desc')
                .get();
            
            const alertsData = [];
            const userIds = new Set();
            
            alertsSnap.forEach(doc => {
                const alert = { id: doc.id, ...doc.data() };
                alertsData.push(alert);
                if (alert.userId) userIds.add(alert.userId);
            });
            
            if (userIds.size > 0) {
                const userResults = await batchQuery('users',
                    firebase.firestore.FieldPath.documentId(),
                    Array.from(userIds)
                );
                
                const userMap = {};
                userResults.forEach(user => {
                    userMap[user.id] = user.displayName || user.email;
                });
                
                alertsData.forEach(alert => {
                    alert.userName = userMap[alert.userId] || 'Unknown User';
                });
            }
            
            setAlerts(alertsData);
            setFilteredAlerts(alertsData);
        } catch (error) {
            console.error('Error loading alerts:', error);
            alert('Failed to load alerts');
        } finally {
            setLoading(false);
        }
    };

    // Helper: Format response time in human-readable format
    const formatResponseTime = (minutes) => {
        if (minutes === 0) return '0m';
        const hours = Math.floor(minutes / 60);
        const mins = Math.round(minutes % 60);
        if (hours === 0) return `${mins}m`;
        if (mins === 0) return `${hours}h`;
        return `${hours}h ${mins}m`;
    };

    const calculateStats = () => {
        const total = alerts.length;
        const active = alerts.filter(a => a.status === 'active').length;
        const critical = alerts.filter(a => a.severity === 'critical' && a.status === 'active').length;

        // Calculate type-specific stats
        const calculateTypeStats = (type) => {
            const typeAlerts = alerts.filter(a => a.type === type);
            const resolvedTypeAlerts = typeAlerts.filter(a => a.resolved && a.createdAt && a.resolvedAt);

            let totalMinutes = 0;
            resolvedTypeAlerts.forEach(alert => {
                const created = alert.createdAt.toDate ? alert.createdAt.toDate() : new Date(alert.createdAt);
                const resolved = alert.resolvedAt.toDate ? alert.resolvedAt.toDate() : new Date(alert.resolvedAt);
                const minutes = (resolved - created) / 1000 / 60;
                totalMinutes += minutes;
            });

            return {
                count: typeAlerts.length,
                avgResponseTime: resolvedTypeAlerts.length > 0
                    ? Math.round(totalMinutes / resolvedTypeAlerts.length)
                    : 0
            };
        };

        const sos = calculateTypeStats('sos');
        const missedCheckin = calculateTypeStats('missed_checkin');
        const highCraving = calculateTypeStats('high_craving');
        const customThreshold = { count: alerts.filter(a => a.type === 'custom' || a.type === 'system').length };

        setStats({
            total,
            active,
            critical,
            sos,
            missedCheckin,
            highCraving,
            customThreshold
        });
    };

    const prepareFrequencyData = () => {
        const last7Days = [];
        const counts = [];
        
        for (let i = 6; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            date.setHours(0, 0, 0, 0);
            
            const nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);
            
            const dayAlerts = alerts.filter(alert => {
                const alertDate = alert.createdAt?.toDate ? alert.createdAt.toDate() : new Date(alert.createdAt);
                return alertDate >= date && alertDate < nextDay;
            });
            
            last7Days.push(date.toLocaleDateString('en-US', { weekday: 'short' }));
            counts.push(dayAlerts.length);
        }
        
        setFrequencyData({ labels: last7Days, data: counts });
    };

    const renderFrequencyChart = () => {
        if (chartInstance.current) {
            chartInstance.current.destroy();
        }
        
        const ctx = frequencyChartRef.current?.getContext('2d');
        if (ctx) {
            chartInstance.current = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: frequencyData.labels,
                    datasets: [{
                        label: 'Alerts',
                        data: frequencyData.data,
                        backgroundColor: 'rgba(102, 126, 234, 0.8)',
                        borderColor: '#0077CC',
                        borderWidth: 2,
                        borderRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: { stepSize: 1 }
                        }
                    },
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
    };

    const filterAlerts = () => {
        let filtered = alerts;
        
        if (filterType !== 'all') {
            filtered = filtered.filter(alert => alert.type === filterType);
        }
        
        if (filterPriority !== 'all') {
            filtered = filtered.filter(alert => alert.priority === filterPriority);
        }
        
        if (filterResolved === 'resolved') {
            filtered = filtered.filter(alert => alert.resolved);
        } else if (filterResolved === 'unresolved') {
            filtered = filtered.filter(alert => !alert.resolved);
        }
        
        if (searchQuery) {
            const query = searchQuery.toLowerCase();
            filtered = filtered.filter(alert =>
                alert.userName?.toLowerCase().includes(query) ||
                alert.message?.toLowerCase().includes(query) ||
                alert.type?.toLowerCase().includes(query)
            );
        }
        
        setFilteredAlerts(filtered);
        setCurrentPage(1);
    };

    const handleQuickResolve = async (alertId) => {
        try {
            await db.collection('alerts').doc(alertId).update({
                resolved: true,
                status: 'resolved',
                resolvedBy: user.uid,
                resolvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                resolutionNotes: 'Quick resolved'
            });
            
            setAlerts(prev => prev.map(a => 
                a.id === alertId ? { ...a, resolved: true, status: 'resolved', resolutionNotes: 'Quick resolved' } : a
            ));
        } catch (error) {
            console.error('Error quick resolving:', error);
            alert('Failed to resolve alert');
        }
    };

    const handleResolve = async (alertId, notes = '') => {
        try {
            await db.collection('alerts').doc(alertId).update({
                resolved: true,
                status: 'resolved',
                resolvedBy: user.uid,
                resolvedAt: firebase.firestore.FieldValue.serverTimestamp(),
                resolutionNotes: notes
            });
            
            setAlerts(prev => prev.map(a => 
                a.id === alertId ? { ...a, resolved: true, status: 'resolved', resolutionNotes: notes } : a
            ));
            
            alert('Alert resolved successfully');
        } catch (error) {
            console.error('Error resolving alert:', error);
            alert('Failed to resolve alert');
        }
    };

    const handleDelete = async (alertId) => {
        if (!confirm('Are you sure you want to delete this alert?')) return;
        
        try {
            await db.collection('alerts').doc(alertId).delete();
            setAlerts(prev => prev.filter(a => a.id !== alertId));
            alert('Alert deleted');
        } catch (error) {
            console.error('Error deleting alert:', error);
            alert('Failed to delete alert');
        }
    };

    const getPriorityColor = (priority) => {
        if (priority === 'critical') return '#f44336';
        if (priority === 'high') return '#FF9800';
        if (priority === 'medium') return '#FFC107';
        return '#00A86B';
    };

    const paginatedAlerts = useMemo(() => {
        const start = (currentPage - 1) * itemsPerPage;
        const end = start + itemsPerPage;
        return filteredAlerts.slice(start, end);
    }, [filteredAlerts, currentPage]);

    const totalPages = Math.ceil(filteredAlerts.length / itemsPerPage);

    const handleExport = (format) => {
        const exportData = filteredAlerts.map(alert => ({
            user: alert.userName,
            type: alert.type,
            priority: alert.priority || 'Normal',
            message: alert.message,
            status: alert.resolved ? 'Resolved' : 'Active',
            createdAt: formatDateTime(alert.createdAt),
            resolvedAt: alert.resolvedAt ? formatDateTime(alert.resolvedAt) : 'N/A',
            resolutionNotes: alert.resolutionNotes || 'N/A',
            emailSent: alert.emailSent ? 'Yes' : 'No'
        }));

        if (format === 'json') {
            exportToJSON(exportData, 'alerts');
        } else if (format === 'csv') {
            exportToCSV(exportData, 'alerts');
        } else if (format === 'pdf') {
            exportToPDF(exportData, 'Alerts Report');
        }
    };

    if (loading) {
        return (
            <div style={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                minHeight: '400px',
                gap: '20px'
            }}>
                <div style={{
                    width: '60px',
                    height: '60px',
                    border: '4px solid #f3f3f3',
                    borderTop: '4px solid #0077CC',
                    borderRadius: '50%',
                    animation: 'spin 1s linear infinite'
                }}></div>
                <p style={{ color: '#666' }}>Loading alerts...</p>
            </div>
        );
    }

    return (
        <div style={{ padding: '20px', animation: 'fadeIn 0.5s' }}>
            {/* Stats Cards */}
            <div style={{
                display: 'grid',
                gridTemplateColumns: 'repeat(auto-fit, minmax(240px, 1fr))',
                gap: '20px',
                marginBottom: '30px'
            }}>
                {/* Total Alerts */}
                <div style={{
                    background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(102, 126, 234, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Total Alerts</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.total}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>All time</div>
                </div>

                {/* Active Alerts */}
                <div style={{
                    background: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(240, 147, 251, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9 }}>Active Alerts</div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.active}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>Need attention</div>
                </div>

                {/* SOS Alerts */}
                <div style={{
                    background: 'linear-gradient(135deg, #ff4444 0%, #cc0000 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(255, 68, 68, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9, display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <span>ðŸš¨</span> SOS Alerts
                    </div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.sos.count}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>
                        Avg response: {formatResponseTime(stats.sos.avgResponseTime)}
                    </div>
                </div>

                {/* Missed Check-ins */}
                <div style={{
                    background: 'linear-gradient(135deg, #FF9800 0%, #FF6B00 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(255, 152, 0, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9, display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <span>â°</span> Missed Check-ins
                    </div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.missedCheckin.count}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>
                        Avg response: {formatResponseTime(stats.missedCheckin.avgResponseTime)}
                    </div>
                </div>

                {/* High Craving Alerts */}
                <div style={{
                    background: 'linear-gradient(135deg, #FFC107 0%, #FFA000 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(255, 193, 7, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9, display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <span>âš ï¸</span> High Craving
                    </div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.highCraving.count}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>
                        Avg response: {formatResponseTime(stats.highCraving.avgResponseTime)}
                    </div>
                </div>

                {/* Custom Threshold Alerts */}
                <div style={{
                    background: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
                    borderRadius: '15px',
                    padding: '25px',
                    color: 'white',
                    boxShadow: '0 4px 15px rgba(79, 172, 254, 0.3)',
                    transition: 'transform 0.2s'
                }}
                onMouseEnter={(e) => e.currentTarget.style.transform = 'translateY(-5px)'}
                onMouseLeave={(e) => e.currentTarget.style.transform = 'translateY(0)'}
                >
                    <div style={{ fontSize: '14px', opacity: 0.9, display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <span>ðŸ””</span> Custom/System
                    </div>
                    <div style={{ fontSize: '42px', fontWeight: 'bold', margin: '10px 0' }}>
                        {stats.customThreshold.count}
                    </div>
                    <div style={{ fontSize: '12px', opacity: 0.8 }}>
                        Other alert types
                    </div>
                </div>
            </div>

            {/* Alert Frequency Chart */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '25px',
                marginBottom: '30px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <h3 style={{ margin: '0 0 20px 0', color: '#333' }}>Alert Frequency - Last 7 Days</h3>
                <div style={{ height: '250px' }}>
                    <canvas ref={frequencyChartRef}></canvas>
                </div>
            </div>

            {/* SOS Alert Banner */}
            {filteredAlerts.filter(a => a.type === 'sos' && a.status === 'active').length > 0 && (
                <div style={{
                    background: 'linear-gradient(135deg, #ff4444, #cc0000)',
                    padding: '20px',
                    borderRadius: '15px',
                    marginBottom: '20px',
                    animation: 'pulse 2s infinite',
                    boxShadow: '0 4px 15px rgba(255, 68, 68, 0.4)'
                }}>
                    <div style={{ display: 'flex', alignItems: 'center', gap: '15px', color: 'white' }}>
                        <span style={{ fontSize: '32px' }}>ðŸš¨</span>
                        <div>
                            <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '5px' }}>
                                {filteredAlerts.filter(a => a.type === 'sos' && a.status === 'active').length} Active SOS Alert(s)
                            </div>
                            <div style={{ fontSize: '14px', opacity: 0.9 }}>
                                Immediate attention required - Email notifications sent automatically
                            </div>
                        </div>
                    </div>
                </div>
            )}
            
            {/* Filters and Actions Bar */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                padding: '20px',
                marginBottom: '20px',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', flexWrap: 'wrap', gap: '15px' }}>
                    <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap' }}>
                        <select 
                            value={filterType}
                            onChange={(e) => setFilterType(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Types</option>
                            <option value="sos">SOS Emergency</option>
                            <option value="missed_checkin">Missed Check-in</option>
                            <option value="low_mood">Low Mood</option>
                            <option value="high_craving">High Craving</option>
                            <option value="system">System Alert</option>
                        </select>
                        
                        <select 
                            value={filterPriority}
                            onChange={(e) => setFilterPriority(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Priorities</option>
                            <option value="critical">Critical</option>
                            <option value="high">High</option>
                            <option value="medium">Medium</option>
                            <option value="low">Low</option>
                        </select>
                        
                        <select 
                            value={filterResolved}
                            onChange={(e) => setFilterResolved(e.target.value)}
                            style={{
                                padding: '8px 12px',
                                borderRadius: '8px',
                                border: '1px solid #ddd',
                                background: 'white',
                                cursor: 'pointer',
                                fontSize: '14px'
                            }}
                        >
                            <option value="all">All Status</option>
                            <option value="unresolved">Active</option>
                            <option value="resolved">Resolved</option>
                        </select>
                    </div>
                    
                    <div style={{ display: 'flex', gap: '10px' }}>
                        <button 
                            onClick={() => handleExport('csv')}
                            style={{
                                padding: '10px 16px',
                                background: '#6c757d',
                                color: 'white',
                                border: 'none',
                                borderRadius: '8px',
                                cursor: 'pointer',
                                fontSize: '14px',
                                fontWeight: '500'
                            }}
                        >
                            Export CSV
                        </button>
                    </div>
                </div>
            </div>
            
            {/* Enhanced Table */}
            <div style={{
                background: 'white',
                borderRadius: '15px',
                overflow: 'hidden',
                boxShadow: '0 2px 8px rgba(0,0,0,0.08)'
            }}>
                <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                    <thead>
                        <tr style={{ background: '#f8f9fa', borderBottom: '2px solid #e9ecef' }}>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Priority</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>User</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Type</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Message</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Status</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Email</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Created</th>
                            <th style={{ padding: '15px', textAlign: 'left', fontWeight: '600', color: '#495057' }}>Actions</th>
                        </tr>
                    </thead>
                    <tbody>
                        {paginatedAlerts.map(alert => (
                            <tr key={alert.id} style={{
                                borderBottom: '1px solid #f0f0f0',
                                transition: 'all 0.2s',
                                background: alert.type === 'sos' && alert.status === 'active' ? 'rgba(244, 67, 54, 0.05)' : 'white',
                                borderLeft: `4px solid ${getPriorityColor(alert.severity || 'low')}`
                            }}
                            onMouseEnter={(e) => {
                                e.currentTarget.style.background = '#f8f9fa';
                            }}
                            onMouseLeave={(e) => {
                                e.currentTarget.style.background = alert.type === 'sos' && alert.status === 'active' ? 'rgba(244, 67, 54, 0.05)' : 'white';
                            }}
                            >
                                <td style={{ padding: '15px' }}>
                                    <div style={{
                                        width: '12px',
                                        height: '12px',
                                        borderRadius: '50%',
                                        background: getPriorityColor(alert.severity || 'low')
                                    }}></div>
                                </td>
                                <td style={{ padding: '15px', fontWeight: '500', color: '#333' }}>
                                    {alert.userName}
                                </td>
                                <td style={{ padding: '15px' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '12px',
                                        fontWeight: '500',
                                        background: alert.type === 'sos' ? '#ffebee' : '#e3f2fd',
                                        color: alert.type === 'sos' ? '#c62828' : '#1565c0'
                                    }}>
                                        {alert.type === 'sos' ? 'ðŸš¨ SOS' : alert.type?.replace('_', ' ')}
                                    </span>
                                </td>
                                <td style={{ padding: '15px', color: '#666', maxWidth: '200px', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
                                    {alert.message}
                                </td>
                                <td style={{ padding: '15px' }}>
                                    <span style={{
                                        padding: '4px 12px',
                                        borderRadius: '20px',
                                        fontSize: '12px',
                                        fontWeight: '500',
                                        background: alert.status === 'resolved' ? '#d4edda' : '#f8d7da',
                                        color: alert.status === 'resolved' ? '#155724' : '#721c24'
                                    }}>
                                        {alert.status === 'resolved' ? 'Resolved' : 'Active'}
                                    </span>
                                </td>
                                <td style={{ padding: '15px' }}>
                                    {alert.emailSent ? (
                                        <span style={{ color: '#00A86B', fontSize: '16px' }} title="Email sent">âœ“</span>
                                    ) : (
                                        <span style={{ color: '#999', fontSize: '16px' }} title="No email sent">â€”</span>
                                    )}
                                </td>
                                <td style={{ padding: '15px', color: '#666' }}>{formatTimeAgo(alert.createdAt)}</td>
                                <td style={{ padding: '15px' }}>
                                    <div style={{ display: 'flex', gap: '8px' }}>
                                        <button 
                                            onClick={() => setSelectedAlert(alert)}
                                            style={{
                                                padding: '6px 12px',
                                                background: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)',
                                                color: 'white',
                                                border: 'none',
                                                borderRadius: '6px',
                                                cursor: 'pointer',
                                                fontSize: '13px',
                                                fontWeight: '500'
                                            }}
                                        >
                                            View
                                        </button>
                                        {alert.status !== 'resolved' && (
                                            <button 
                                                onClick={() => handleQuickResolve(alert.id)}
                                                style={{
                                                    padding: '6px 12px',
                                                    background: '#00A86B',
                                                    color: 'white',
                                                    border: 'none',
                                                    borderRadius: '6px',
                                                    cursor: 'pointer',
                                                    fontSize: '13px',
                                                    fontWeight: '500'
                                                }}
                                            >
                                                Quick Resolve
                                            </button>
                                        )}
                                    </div>
                                </td>
                            </tr>
                        ))}
                    </tbody>
                </table>
                
                {filteredAlerts.length === 0 && (
                    <div style={{
                        padding: '60px 20px',
                        textAlign: 'center',
                        color: '#999'
                    }}>
                        <div style={{ fontSize: '48px', marginBottom: '15px' }}>ðŸ””</div>
                        <div style={{ fontSize: '18px', fontWeight: '500', marginBottom: '8px' }}>
                            No alerts found
                        </div>
                        <div style={{ fontSize: '14px' }}>
                            {searchQuery ? 'Try adjusting your search terms' : 'Alerts will appear here when triggered'}
                        </div>
                    </div>
                )}
            </div>
            
            {totalPages > 1 && (
                <div style={{ marginTop: '20px' }}>
                    <Pagination 
                        currentPage={currentPage}
                        totalPages={totalPages}
                        onPageChange={setCurrentPage}
                    />
                </div>
            )}
            
            {selectedAlert && (
                <AlertDetailModal 
                    alert={selectedAlert}
                    onClose={() => setSelectedAlert(null)}
                    onResolve={handleResolve}
                    getPriorityColor={getPriorityColor}
                />
            )}
        </div>
    );
}
      // ==================== COMPLETE REPORTS VIEW - FULL PRODUCTION VERSION ====================

function ReportsView({ user }) {
    // ========== STATE MANAGEMENT ==========
    const [reportMode, setReportMode] = useState('templates');
    const [selectedTemplate, setSelectedTemplate] = useState('overview');
    const [startDate, setStartDate] = useState(() => {
        const date = new Date();
        date.setMonth(date.getMonth() - 1);
        return date.toISOString().split('T')[0];
    });
    const [endDate, setEndDate] = useState(() => new Date().toISOString().split('T')[0]);
    const [reportData, setReportData] = useState(null);
    const [loading, setLoading] = useState(false);
    const [showAnalytics, setShowAnalytics] = useState(false);
    const [analyticsData, setAnalyticsData] = useState(null);
    const [selectedPIRForReport, setSelectedPIRForReport] = useState(null);
    const [allPIRs, setAllPIRs] = useState([]);
    const [allCheckIns, setAllCheckIns] = useState([]);
   const [sendingWeekly, setSendingWeekly] = useState(false);
    const [sendingMonthly, setSendingMonthly] = useState(false);
    
    // ========== NEW: AUTOMATION CONFIGURATION STATE ==========
    const [selectedReports, setSelectedReports] = useState({
        morningCheckins: true,
        eveningReflections: true,
        moodAnalysis: true,
        overview: false,
        sobriety: false,
        engagement: false,
        milestones: false,
        crisis: false,
        communication: false,
        predictive: false
    });
    
    const [automationEnabled, setAutomationEnabled] = useState(true);
    
    const [scheduleConfig, setScheduleConfig] = useState({
        weekly: {
            day: 1, // Monday = 1
            time: '08:00'
        },
        monthly: {
            day: 2, // 2nd of month
            time: '08:00'
        }
    });
    
    const [lastRunStatus, setLastRunStatus] = useState({
        weekly: null,
        monthly: null
    });
    
    const [customConfig, setCustomConfig] = useState({
        selectedPIRs: [],
        selectedMetrics: {
            mood: true,
            cravings: true,
            anxiety: true,
            sleep: true,
            gratitude: false,
            challenges: false,
            goals: false
        },
        selectedCharts: {
            moodVsCravings: true,
            anxietyVsSleep: true,
            trends: true,
            distribution: true,
            patternAnalysis: true
        },
        includeTables: true,
        includePatterns: true,
        includeSummary: true
    });

   // ========== CHART REFERENCES ==========
const chartRefs = {
    moodTrend: useRef(null),
    cravingTrend: useRef(null),
    anxietyTrend: useRef(null),
    sleepTrend: useRef(null),
    moodVsCravings: useRef(null),
    anxietyVsSleep: useRef(null),
    moodDistribution: useRef(null),
    riskDistribution: useRef(null),
    complianceChart: useRef(null),
    engagementChart: useRef(null),
    sobrietyVsCravings: useRef(null),
    goalCompletion: useRef(null),
    overallDayTrend: useRef(null),
    dayQualityPie: useRef(null),
    completionBar: useRef(null)
};
const chartInstances = useRef({});
    // ========== REPORT TEMPLATES ==========
    const REPORT_TEMPLATES = {
        overview: {
            name: 'Program Overview',
            icon: 'ðŸ“Š',
            desc: 'Complete program statistics and trends',
            color: 'linear-gradient(135deg, #0077CC 0%, #008B8B 100%)'
        },
        sobriety: {
            name: 'Sobriety Analysis',
            icon: 'ðŸŽ¯',
            desc: 'Sobriety tracking and risk assessment',
            color: 'linear-gradient(135deg, #00A86B 0%, #008554 100%)'
        },
        morningCheckins: {
            name: 'Morning Check-ins',
            icon: 'ðŸŒ…',
            desc: 'Morning mood and craving analysis',
            color: 'linear-gradient(135deg, #FF9800 0%, #F57C00 100%)'
        },
        eveningReflections: {
            name: 'Evening Reflections',
            icon: 'ðŸŒ™',
            desc: 'Daily reflections and gratitude',
            color: 'linear-gradient(135deg, #9C27B0 0%, #7B1FA2 100%)'
        },
        fullPIR: {
            name: 'Full PIR Report',
            icon: 'ðŸ“‹',
            desc: 'Comprehensive individual analysis',
            color: 'linear-gradient(135deg, #2196F3 0%, #1976D2 100%)'
        },
        moodAnalysis: {
            name: 'Mood Analysis',
            icon: 'ðŸ˜Š',
            desc: 'Detailed mood patterns and trends',
            color: 'linear-gradient(135deg, #00BCD4 0%, #0097A7 100%)'
        },
        crisis: {
            name: 'Crisis & Intervention',
            icon: 'ðŸš¨',
            desc: 'SOS alerts and emergency response',
            color: 'linear-gradient(135deg, #f44336 0%, #B01030 100%)'
        },
        engagement: {
            name: 'Engagement Report',
            icon: 'ðŸ“ˆ',
            desc: 'PIR engagement and participation',
            color: 'linear-gradient(135deg, #FF5722 0%, #E64A19 100%)'
        },
        comparative: {
            name: 'Comparative Analysis',
            icon: 'âš–ï¸',
            desc: 'Compare PIR vs program averages',
            color: 'linear-gradient(135deg, #795548 0%, #5D4037 100%)'
        },
        milestones: {
            name: 'Milestones & Achievements',
            icon: 'ðŸ†',
            desc: 'Goals and milestone tracking',
            color: 'linear-gradient(135deg, #FFC107 0%, #FFA000 100%)'
        },
        communication: {
            name: 'Communication Report',
            icon: 'ðŸ’¬',
            desc: 'Message activity and engagement',
            color: 'linear-gradient(135deg, #607D8B 0%, #455A64 100%)'
        },
        predictive: {
            name: 'Predictive Risk',
            icon: 'âš ï¸',
            desc: 'Risk prediction and early warnings',
            color: 'linear-gradient(135deg, #E91E63 0%, #C2185B 100%)'
        }
    };

    // ========== INITIALIZATION ==========
   useEffect(() => {
        loadPIRsList();
        loadAllCheckIns();
        return () => {
            Object.values(chartInstances.current).forEach(chart => {
                if (chart) chart.destroy();
            });
        };
    }, []);

    // ========== NEW: LOAD AUTOMATION CONFIG ON MOUNT ==========
    useEffect(() => {
        loadAutomationConfig();
    }, []);
   

    useEffect(() => {
        if (reportData && reportData.charts) {
            setTimeout(() => renderCharts(), 150);
        }
    }, [reportData]);

    useEffect(() => {
        if (allCheckIns.length > 0) {
            calculateAnalytics();
        }
    }, [allCheckIns]);

    const loadPIRsList = async () => {
        try {
            const pirsSnap = await db.collection('users')
                .where('role', '==', 'pir')
                .get();
            
            setAllPIRs(pirsSnap.docs.map(doc => ({
                id: doc.id,
                name: doc.data().displayName || doc.data().email
            })));
        } catch (error) {
            console.error('Error loading PIRs:', error);
        }
    };

    const loadAllCheckIns = async () => {
        try {
            const checkInsSnap = await db.collection('checkIns')
                .orderBy('createdAt', 'desc')
                .limit(1000)
                .get();
            
            const checkInsData = [];
            const usersCache = {};
            
            for (const doc of checkInsSnap.docs) {
                const checkIn = { id: doc.id, ...doc.data() };
                
                if (!usersCache[checkIn.userId]) {
                    const userDoc = await db.collection('users').doc(checkIn.userId).get();
                    usersCache[checkIn.userId] = userDoc.data()?.displayName || userDoc.data()?.email || 'Unknown';
                }
                
                checkIn.userName = usersCache[checkIn.userId];
                checkInsData.push(checkIn);
            }
            
            setAllCheckIns(checkInsData);
        } catch (error) {
            console.error('Error loading check-ins:', error);
        }
    };
// ==========================================
// WORKING GOOGLE TOKEN REFRESH (INSIDE COMPONENT)
// ==========================================
const refreshGoogleToken = async () => {
    return new Promise((resolve, reject) => {
        try {
            console.log('ðŸ”„ Attempting to refresh Google token...');
            
            // Check if Google Identity Services is loaded
            if (typeof google === 'undefined' || !google.accounts) {
                reject(new Error('Google Identity Services not loaded'));
                return;
            }
            
            // Use token client to get new token silently
            const tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: '457406864879-k1sunucuqofe22m5rg93hvo6nngiqh0u.apps.googleusercontent.com',
                scope: [
                    'https://www.googleapis.com/auth/calendar.events',
                    'https://www.googleapis.com/auth/drive.file'
                ].join(' '),
                callback: async (tokenResponse) => {
                    try {
                        if (tokenResponse.error) {
                            reject(new Error(tokenResponse.error));
                            return;
                        }
                        
                        if (tokenResponse.access_token) {
                            // Update Firebase with new token
                            await db.collection('users').doc(user.uid).update({
                                googleAccessToken: tokenResponse.access_token,
                                googleTokenExpiry: Date.now() + (tokenResponse.expires_in * 1000),
                                googleTokenRefreshedAt: firebase.firestore.FieldValue.serverTimestamp()
                            });
                            
                            // Update local user object
                            user.googleAccessToken = tokenResponse.access_token;
                            user.googleTokenExpiry = Date.now() + (tokenResponse.expires_in * 1000);
                            
                            console.log('âœ… Token refreshed successfully');
                            resolve(tokenResponse.access_token);
                        } else {
                            reject(new Error('No access token received'));
                        }
                    } catch (error) {
                        reject(error);
                    }
                },
            });
            
            // Request new token silently (no popup unless necessary)
            tokenClient.requestAccessToken({ prompt: '' });
            
        } catch (error) {
            console.error('âŒ Failed to refresh token:', error);
            reject(error);
        }
    });
};

// ==========================================
// CHECK & AUTO-REFRESH GOOGLE TOKEN (INSIDE COMPONENT)
// ==========================================
const checkAndRefreshGoogleToken = async () => {
    try {
        // Check if user has Google connected
        if (!user.googleConnected || !user.googleAccessToken) {
            throw new Error('Google Services not connected. Please connect Google in your Profile settings.');
        }
        
        // Check if token is expired or about to expire
        if (user.googleTokenExpiry) {
            const now = Date.now();
            const expiryTime = user.googleTokenExpiry;
            const fiveMinutes = 5 * 60 * 1000;
            
            if (now >= expiryTime - fiveMinutes) {
                console.log('âš ï¸ Token expired, refreshing...');
                await refreshGoogleToken();
            }
        }
        
        console.log('âœ… Token validated');
        return user.googleAccessToken;
        
    } catch (error) {
        console.error('âŒ Token validation failed:', error);
        throw new Error('Google token invalid. Please reconnect Google in Profile settings.');
    }
};
   // ==========================================
// AUTOMATION CONFIGURATION MANAGEMENT
// ==========================================

// ========== SAVE AUTOMATION CONFIG TO FIREBASE ==========
const saveAutomationConfig = async () => {
    try {
        console.log('ðŸ’¾ Saving automation configuration...');
        
        await db.collection('automationConfig').doc(user.uid).set({
            userId: user.uid,
            enabled: automationEnabled,
            selectedReports,
            schedule: scheduleConfig,
            lastRunStatus,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        console.log('âœ… Automation configuration saved');
        alert('âœ… Configuration saved successfully!');
        
    } catch (error) {
        console.error('âŒ Error saving automation config:', error);
        alert('âŒ Failed to save configuration. Check console for details.');
    }
};

// ========== LOAD AUTOMATION CONFIG FROM FIREBASE ==========
const loadAutomationConfig = async () => {
    try {
        console.log('ðŸ“¥ Loading automation configuration...');
        
        const configDoc = await db.collection('automationConfig').doc(user.uid).get();
        
        if (configDoc.exists) {
            const config = configDoc.data();
            
            setAutomationEnabled(config.enabled ?? true);
            setSelectedReports(config.selectedReports ?? {
                morningCheckins: true,
                eveningReflections: true,
                moodAnalysis: true,
                overview: false,
                sobriety: false,
                engagement: false,
                milestones: false,
                crisis: false,
                communication: false,
                predictive: false
            });
            setScheduleConfig(config.schedule ?? {
                weekly: { day: 1, time: '08:00' },
                monthly: { day: 2, time: '08:00' }
            });
            setLastRunStatus(config.lastRunStatus ?? {
                weekly: null,
                monthly: null
            });
            
            console.log('âœ… Automation configuration loaded');
        } else {
            console.log('â„¹ï¸ No saved configuration found, using defaults');
        }
        
    } catch (error) {
        console.error('âŒ Error loading automation config:', error);
    }
};

// ========== TEST WEEKLY REPORTS (SEND TO ALL PIRS) ==========
const testWeeklyReports = async () => {
    if (!confirm('ðŸ§ª TEST MODE: Send weekly reports to ALL active PIRs right now?\n\nThis uses the currently selected reports.')) {
        return;
    }
    
    try {
        setSendingWeekly(true);
        await sendAllWeeklyReports();
    } catch (error) {
        console.error('âŒ Error testing weekly reports:', error);
        alert(`âŒ Error: ${error.message}`);
    } finally {
        setSendingWeekly(false);
    }
};

// ========== TEST MONTHLY REPORTS (SEND TO ALL PIRS) ==========
const testMonthlyReports = async () => {
    if (!confirm('ðŸ§ª TEST MODE: Send monthly reports to ALL active PIRs right now?\n\nThis uses the currently selected reports.')) {
        return;
    }
    
    try {
        setSendingMonthly(true);
        await sendAllMonthlyReports();
    } catch (error) {
        console.error('âŒ Error testing monthly reports:', error);
        alert(`âŒ Error: ${error.message}`);
    } finally {
        setSendingMonthly(false);
    }
};

// ========== CONSTANTS ==========
const GLRS_MAIN_FOLDER_ID = '1Nuem8Nw8a3LxkVya0U3GcV6nwmdp3VCw';
const GLRS_LOGO_BASE64 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEu0lEQVR4nO2ZW2wUVRzGv5mdmd3Z7rbbXbe7pbQtpRRKS0sRKBcRUB4UH4zRxBuJMSZqfPBBTXzwwQcTE40vvhhj4oMxMcYHE2OMiTHGGBNjjIkxxhgTY4yJMcYYY2L8zjkz252d2Z3tbktL0ZN8yc7MmXP+3/87l9kBHnjggQceeOD/Dco0KKVUSimlUkqplFIqpZRKKaVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppVRKKZVSSqn/r1JKqZRSKqWUSilVSimVUkqllFIppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoppZRSKqWUSv2/lVJKpZRSKaVUSqmUUiqllFIppVRKKZVSSqmUUiqllEoppVRKKZVSSqmUUiqllEoplVJKpZRSKaVUSqmUUkqllFIppVRKqZRSKqWUSqmUUiqllFIppf7fSimlUkqplFIqpZRKKaVSSqmUUiqllEoplVJKpZRKKaVSSqmUUiqllEoplVJKpZRSKaVUSqmUUkqllFIppVRKqZRSKqWUSqmUUiqllFIppf7fSimlUkqplFIqpZRKKaVSSqmUUiqllEoplVJKpZRKKaVSSqmUUiqllEoplVJKpZRSKaVUSqmUUkqllFIppVRKqZRSKqWUSqmUUiqllFIppf7fSimlUkqplFIqpZRKKaVSSqmUUiqllEoplVJKpZRKKaVSSqmUUiqllEoplVJKpZRSKaVUSqmUUkqllFIppVRKqZRSKqWUSqmUUiqllFIppf7fSimlUkqplFIqpZRKKaVSSqmUUiqllEoplVJKpZRKKaVSSqmUUiqllEoplVJKpZRSKaVUSqmUUkqllFIppVRKqZRSKqWUSqmUUiqllFIppf7/6k+xKg0Q8QAAAABJRU5ErkJggg==";

// ========== AVAILABLE REPORTS CONFIGURATION ==========
const AVAILABLE_REPORTS = {
    morningCheckins: {
        name: 'Morning Check-ins',
        generator: null, // Will be set to function reference
        key: 'morningCheckins',
        icon: 'ðŸŒ…',
        description: 'Daily morning mood, cravings, anxiety, and sleep quality'
    },
    eveningReflections: {
        name: 'Evening Reflections',
        generator: null,
        key: 'eveningReflections',
        icon: 'ðŸŒ™',
        description: 'Daily reflections, gratitude, and challenges'
    },
    moodAnalysis: {
        name: 'Mood Analysis',
        generator: null,
        key: 'moodAnalysis',
        icon: 'ðŸ˜Š',
        description: 'Detailed mood patterns and distribution'
    },
    overview: {
        name: 'Overview Report',
        generator: null,
        key: 'overview',
        icon: 'ðŸ“Š',
        description: 'Comprehensive progress statistics'
    },
    sobriety: {
        name: 'Sobriety Analysis',
        generator: null,
        key: 'sobriety',
        icon: 'ðŸŽ¯',
        description: 'Sobriety tracking and risk assessment'
    },
    engagement: {
        name: 'Engagement Report',
        generator: null,
        key: 'engagement',
        icon: 'ðŸ“ˆ',
        description: 'Participation and activity metrics'
    },
    milestones: {
        name: 'Milestones & Achievements',
        generator: null,
        key: 'milestones',
        icon: 'ðŸ†',
        description: 'Goals completed and milestones reached'
    },
    crisis: {
        name: 'Crisis & Interventions',
        generator: null,
        key: 'crisis',
        icon: 'ðŸš¨',
        description: 'SOS alerts and emergency responses'
    },
    communication: {
        name: 'Communication Activity',
        generator: null,
        key: 'communication',
        icon: 'ðŸ’¬',
        description: 'Message activity and engagement'
    },
    predictive: {
        name: 'Predictive Risk',
        generator: null,
        key: 'predictive',
        icon: 'âš ï¸',
        description: 'Risk prediction and early warnings'
    }
};
// ========== GOOGLE DRIVE FOLDER MANAGEMENT ==========
const getOrCreatePIRFolder = async (pirName, accessToken) => {
    try {
        console.log(`ðŸ“ Looking for folder: ${pirName}`);
        
        const searchResponse = await fetch(
            `https://www.googleapis.com/drive/v3/files?q=name='${pirName}' and '${GLRS_MAIN_FOLDER_ID}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            }
        );
        
        const searchData = await searchResponse.json();
        
        if (searchData.files && searchData.files.length > 0) {
            console.log(`âœ… Found existing PIR folder: ${searchData.files[0].id}`);
            return searchData.files[0].id;
        }
        
        console.log(`ðŸ“ Creating new PIR folder: ${pirName}`);
        const createResponse = await fetch(
            'https://www.googleapis.com/drive/v3/files',
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: pirName,
                    mimeType: 'application/vnd.google-apps.folder',
                    parents: [GLRS_MAIN_FOLDER_ID]
                })
            }
        );
        
        const createData = await createResponse.json();
        console.log(`âœ… Created PIR folder: ${createData.id}`);
        return createData.id;
        
    } catch (error) {
        console.error('âŒ Error managing PIR folder:', error);
        throw error;
    }
};

const getOrCreateReportTypeFolder = async (pirFolderId, reportType, accessToken) => {
    try {
        const folderName = reportType === 'weekly' ? 'Weekly Reports' : 'Monthly Reports';
        console.log(`ðŸ“ Looking for ${folderName} folder...`);
        
        const searchResponse = await fetch(
            `https://www.googleapis.com/drive/v3/files?q=name='${folderName}' and '${pirFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
            {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            }
        );
        
        const searchData = await searchResponse.json();
        
        if (searchData.files && searchData.files.length > 0) {
            console.log(`âœ… Found existing ${folderName} folder: ${searchData.files[0].id}`);
            return searchData.files[0].id;
        }
        
        console.log(`ðŸ“ Creating ${folderName} folder...`);
        const createResponse = await fetch(
            'https://www.googleapis.com/drive/v3/files',
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: folderName,
                    mimeType: 'application/vnd.google-apps.folder',
                    parents: [pirFolderId]
                })
            }
        );
        
        const createData = await createResponse.json();
        console.log(`âœ… Created ${folderName} folder: ${createData.id}`);
        return createData.id;
        
    } catch (error) {
        console.error(`âŒ Error managing report type folder:`, error);
        throw error;
    }
};

// ========== UPLOAD PDF TO GOOGLE DRIVE ==========
const uploadPDFToDrive = async (pdfBlob, fileName, pirName, reportType, accessToken) => {
    try {
        console.log(`ðŸ“¤ Uploading ${fileName} to Google Drive...`);
        
        const pirFolderId = await getOrCreatePIRFolder(pirName, accessToken);
        const reportFolderId = await getOrCreateReportTypeFolder(pirFolderId, reportType, accessToken);
        
        const metadata = {
            name: fileName,
            mimeType: 'application/pdf',
            parents: [reportFolderId]
        };
        
        const form = new FormData();
        form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));
        form.append('file', pdfBlob);
        
        const uploadResponse = await fetch(
            'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,webViewLink',
            {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${accessToken}` },
                body: form
            }
        );
        
        if (!uploadResponse.ok) {
            const errorText = await uploadResponse.text();
            throw new Error(`Upload failed: ${errorText}`);
        }
        
        const fileData = await uploadResponse.json();
        console.log(`âœ… Uploaded to Drive: ${fileData.id}`);
        
        await fetch(
            `https://www.googleapis.com/drive/v3/files/${fileData.id}/permissions`,
            {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    role: 'reader',
                    type: 'anyone'
                })
            }
        );
        
        console.log(`âœ… Made shareable: ${fileData.webViewLink}`);
        
        return {
            fileId: fileData.id,
            webViewLink: fileData.webViewLink
        };
        
    } catch (error) {
        console.error('âŒ Error uploading to Drive:', error);
        throw error;
    }
};

// ========== GENERATE PDF FROM REPORT DATA ==========
const generatePDFFromReport = async (reportData, reportTitle, pirName, coachName, dateRange) => {
    try {
        console.log(`ðŸ“„ Generating PDF: ${reportTitle}...`);
        
        const container = document.createElement('div');
        container.style.position = 'absolute';
        container.style.left = '-9999px';
        container.style.width = '800px';
        document.body.appendChild(container);
        
        // âœ… FIXED: No full HTML document wrapper, just content
        container.innerHTML = `
            <style>
                * { margin: 0; padding: 0; box-sizing: border-box; }
                body { 
                    font-family: 'Segoe UI', Arial, sans-serif;
                    color: #2c3e50;
                    padding: 40px;
                    line-height: 1.6;
                }
                .header {
                    text-align: center;
                    border-bottom: 3px solid #0077CC;
                    padding-bottom: 20px;
                    margin-bottom: 30px;
                }
                .header h1 {
                    color: #0077CC;
                    font-size: 28px;
                    margin-bottom: 10px;
                }
                .header p {
                    color: #666;
                    font-size: 14px;
                    margin: 5px 0;
                }
                .summary-grid {
                    display: grid;
                    grid-template-columns: repeat(3, 1fr);
                    gap: 15px;
                    margin: 30px 0;
                }
                .summary-card {
                    background: #f8f9fa;
                    padding: 15px;
                    border-left: 4px solid #0077CC;
                    border-radius: 6px;
                }
                .summary-card .label {
                    font-size: 11px;
                    color: #666;
                    text-transform: uppercase;
                    margin-bottom: 5px;
                }
                .summary-card .value {
                    font-size: 24px;
                    color: #0077CC;
                    font-weight: bold;
                }
                .section {
                    margin: 25px 0;
                    page-break-inside: avoid;
                }
                .section-title {
                    color: #0077CC;
                    font-size: 18px;
                    border-bottom: 2px solid #0077CC;
                    padding-bottom: 8px;
                    margin-bottom: 15px;
                }
                .insights-list {
                    list-style: none;
                    margin: 15px 0;
                }
                .insights-list li {
                    background: #e3f2fd;
                    padding: 12px;
                    margin: 8px 0;
                    border-left: 4px solid #0077CC;
                    border-radius: 4px;
                    font-size: 13px;
                }
                .data-table {
                    width: 100%;
                    border-collapse: collapse;
                    margin: 20px 0;
                    font-size: 12px;
                }
                .data-table th {
                    background: #0077CC;
                    color: white;
                    padding: 10px;
                    text-align: left;
                    font-weight: 600;
                }
                .data-table td {
                    padding: 8px 10px;
                    border-bottom: 1px solid #e0e0e0;
                }
                .data-table tr:nth-child(even) {
                    background: #f8f9fa;
                }
                .pattern-box {
                    background: #fff3cd;
                    border-left: 4px solid #ffc107;
                    padding: 12px;
                    margin: 10px 0;
                    border-radius: 4px;
                    font-size: 13px;
                }
                .footer {
                    margin-top: 40px;
                    padding-top: 20px;
                    border-top: 2px solid #e0e0e0;
                    text-align: center;
                    font-size: 11px;
                    color: #999;
                }
            </style>

            <div class="header">
                <h1>${reportTitle}</h1>
                <p><strong>${pirName}</strong></p>
                <p>Coach: ${coachName}</p>
                <p>Period: ${dateRange}</p>
                <p>Generated: ${new Date().toLocaleDateString('en-US')}</p>
            </div>

            ${reportData.summary ? `
                <div class="section">
                    <h2 class="section-title">Summary Statistics</h2>
                    <div class="summary-grid">
                        ${Object.entries(reportData.summary).slice(0, 9).map(([key, value]) => `
                            <div class="summary-card">
                                <div class="label">${key.replace(/([A-Z])/g, ' $1').trim()}</div>
                                <div class="value">${value}</div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            ` : ''}

            ${reportData.insights && reportData.insights.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Key Insights</h2>
                    <ul class="insights-list">
                        ${reportData.insights.map(insight => `<li>${insight}</li>`).join('')}
                    </ul>
                </div>
            ` : ''}

            ${reportData.patterns && reportData.patterns.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Detected Patterns</h2>
                    ${reportData.patterns.map(pattern => `
                        <div class="pattern-box">
                            ${pattern.message || pattern}
                        </div>
                    `).join('')}
                </div>
            ` : ''}

            ${reportData.morningData && reportData.morningData.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Morning Check-in Details</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Mood</th>
                                <th>Craving</th>
                                <th>Anxiety</th>
                                <th>Sleep</th>
                                <th>Notes</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.morningData.slice(0, 20).map(m => {
                                const date = m.date?.toDate ? m.date.toDate() : new Date(m.date);
                                return `
                                    <tr>
                                        <td>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</td>
                                        <td>${m.mood || 'N/A'}/10</td>
                                        <td>${m.craving || 'N/A'}/10</td>
                                        <td>${m.anxiety || 'N/A'}/10</td>
                                        <td>${m.sleep || 'N/A'}/10</td>
                                        <td>${(m.notes || '').substring(0, 30)}${m.notes && m.notes.length > 30 ? '...' : ''}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            ${reportData.eveningData && reportData.eveningData.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Evening Reflection Details</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Overall Day</th>
                                <th>Gratitude</th>
                                <th>Challenges</th>
                                <th>Tomorrow Goal</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.eveningData.slice(0, 20).map(e => {
                                const date = e.date?.toDate ? e.date.toDate() : new Date(e.date);
                                return `
                                    <tr>
                                        <td>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</td>
                                        <td>${e.overallDay || 'N/A'}/10</td>
                                        <td>${(e.gratitude || '').substring(0, 30)}${e.gratitude && e.gratitude.length > 30 ? '...' : ''}</td>
                                        <td>${(e.challenges || '').substring(0, 30)}${e.challenges && e.challenges.length > 30 ? '...' : ''}</td>
                                        <td>${(e.tomorrowGoal || '').substring(0, 30)}${e.tomorrowGoal && e.tomorrowGoal.length > 30 ? '...' : ''}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            ${reportData.sobrietyData && reportData.sobrietyData.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Sobriety Analysis</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>PIR Name</th>
                                <th>Days Sober</th>
                                <th>Avg Mood</th>
                                <th>Avg Cravings</th>
                                <th>Risk Level</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.sobrietyData.slice(0, 20).map(s => `
                                <tr>
                                    <td>${s.pirName}</td>
                                    <td>${s.daysSober} days</td>
                                    <td>${s.avgMood}/10</td>
                                    <td>${s.avgCravings}/10</td>
                                    <td>${s.riskLevel}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            ${reportData.engagementData && reportData.engagementData.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Engagement Details</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>PIR Name</th>
                                <th>Check-ins</th>
                                <th>Streak</th>
                                <th>Assignments</th>
                                <th>Completion %</th>
                                <th>Score</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.engagementData.slice(0, 20).map(e => `
                                <tr>
                                    <td>${e.pirName}</td>
                                    <td>${e.checkInCount}</td>
                                    <td>${e.checkInStreak} days</td>
                                    <td>${e.assignmentCount}</td>
                                    <td>${e.assignmentCompletion}%</td>
                                    <td>${e.engagementScore}/100</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            ${reportData.achievements && reportData.achievements.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Achievements & Milestones</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>PIR Name</th>
                                <th>Type</th>
                                <th>Achievement</th>
                                <th>Date</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.achievements.slice(0, 20).map(a => {
                                const date = a.completedAt?.toDate ? a.completedAt.toDate() : new Date(a.completedAt);
                                return `
                                    <tr>
                                        <td>${a.pirName}</td>
                                        <td>${a.type}</td>
                                        <td>${a.title}</td>
                                        <td>${date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            ${reportData.riskData && reportData.riskData.length > 0 ? `
                <div class="section">
                    <h2 class="section-title">Risk Assessment</h2>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>PIR Name</th>
                                <th>Risk Score</th>
                                <th>Risk Level</th>
                                <th>Detected Patterns</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${reportData.riskData.slice(0, 20).map(r => `
                                <tr>
                                    <td>${r.pirName}</td>
                                    <td>${r.riskScore}/10</td>
                                    <td>${r.riskLevel}</td>
                                    <td>${r.patterns.join(', ')}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            ` : ''}

            <div class="footer">
                <p><strong>Guiding Light Recovery Services</strong></p>
                <p>Confidential Recovery Report - For Professional Use Only</p>
                <p>www.glrecoveryservices.com</p>
            </div>
        `;
        
        const opt = {
            margin: 10,
            filename: `${reportTitle}.pdf`,
            image: { type: 'jpeg', quality: 0.98 },
            html2canvas: { scale: 2, useCORS: true },
            jsPDF: { unit: 'mm', format: 'a4', orientation: 'portrait' }
        };
        
        const pdfBlob = await html2pdf().set(opt).from(container).outputPdf('blob');
        
        document.body.removeChild(container);
        
        console.log(`âœ… PDF generated: ${reportTitle}`);
        return pdfBlob;
        
    } catch (error) {
        console.error('âŒ Error generating PDF:', error);
        throw error;
    }
};

// ========== EMAIL TEMPLATE WITH DYNAMIC DRIVE LINKS ==========
const getEmailTemplateWithDynamicLinks = (pirName, reportType, dateRange, driveLinks) => {
    return `
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
        </head>
        <body style="margin: 0; padding: 0; font-family: Arial, sans-serif; background-color: #f5f5f5;">
            <table width="100%" cellpadding="0" cellspacing="0" style="background-color: #f5f5f5; padding: 20px 0;">
                <tr>
                    <td align="center">
                        <table width="600" cellpadding="0" cellspacing="0" style="background-color: #ffffff; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <tr>
                                <td style="padding: 40px 30px;">
                                    <p style="margin: 0 0 20px 0; font-size: 16px; color: #333;">
                                        Hi ${pirName},
                                    </p>
                                    <p style="margin: 0 0 30px 0; font-size: 14px; color: #666; line-height: 1.6;">
                                        Your ${reportType} progress reports for ${dateRange} are ready! ðŸ“Š
                                    </p>
                                    
                                    <h3 style="margin: 0 0 20px 0; font-size: 16px; color: #0077CC;">ðŸ“„ YOUR REPORTS:</h3>
                                    
                                    ${driveLinks.map(link => `
                                        <div style="margin: 15px 0; padding: 15px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #0077CC;">
                                            <div style="font-weight: 600; color: #333; margin-bottom: 8px;">${link.title}</div>
                                            <a href="${link.url}" target="_blank" style="color: #0077CC; text-decoration: none; font-size: 14px;">
                                                ðŸ“‚ View in Google Drive â†’
                                            </a>
                                        </div>
                                    `).join('')}
                                    
                                    <p style="margin: 30px 0 0 0; font-size: 13px; color: #999;">
                                        Click any link to view, download, or print your reports.
                                    </p>
                                    
                                    <p style="margin: 30px 0 0 0; font-size: 14px; color: #666;">
                                        Best regards,<br>
                                        <strong>Guiding Light Recovery Services</strong>
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td style="background-color: #f9f9f9; padding: 20px 30px; text-align: center; border-top: 1px solid #e0e0e0;">
                                    <p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">
                                        <a href="https://www.glrecoveryservices.com" style="color: #0077CC; text-decoration: none;">www.glrecoveryservices.com</a>
                                    </p>
                                    <p style="margin: 0; font-size: 12px; color: #999;">
                                        Â© 2024 Guiding Light Recovery Services. All Rights Reserved.
                                    </p>
                                </td>
                            </tr>
                        </table>
                    </td>
                </tr>
            </table>
        </body>
        </html>
    `;
};
// ========== SEND WEEKLY PROGRESS REPORTS (DYNAMIC BASED ON SELECTED REPORTS) ==========
const sendWeeklyProgressReport = async (pirId) => {
    try {
        console.log(`ðŸ“§ Generating weekly reports for PIR: ${pirId}`);
        
        // âœ… Check & refresh token before using
        await checkAndRefreshGoogleToken();
        console.log('âœ… Token validated, proceeding with weekly reports...');
        
        const pirDoc = await db.collection('users').doc(pirId).get();
        if (!pirDoc.exists) {
            throw new Error('PIR not found');
        }
        const pirData = pirDoc.data();
        
        let coachName = 'Your Recovery Coach';
        if (pirData.assignedCoach) {
            const coachDoc = await db.collection('users').doc(pirData.assignedCoach).get();
            if (coachDoc.exists) {
                coachName = coachDoc.data().displayName || coachName;
            }
        }
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 6);
        
        const dateRange = `${startDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })} - ${endDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`;
        const dateStamp = endDate.toISOString().split('T')[0];
        
        // âœ… DYNAMICALLY BUILD REPORT LIST BASED ON SELECTED REPORTS
        const reportsToGenerate = [];
        const reportTitles = [];
        
        // Set generator functions (they're defined later in the code)
        AVAILABLE_REPORTS.morningCheckins.generator = generateMorningCheckinsReport;
        AVAILABLE_REPORTS.eveningReflections.generator = generateEveningReflectionsReport;
        AVAILABLE_REPORTS.moodAnalysis.generator = generateMoodAnalysisReport;
        AVAILABLE_REPORTS.overview.generator = generateOverviewReport;
        AVAILABLE_REPORTS.sobriety.generator = generateSobrietyReport;
        AVAILABLE_REPORTS.engagement.generator = generateEngagementReport;
        AVAILABLE_REPORTS.milestones.generator = generateMilestonesReport;
        AVAILABLE_REPORTS.crisis.generator = generateCrisisReport;
        AVAILABLE_REPORTS.communication.generator = generateCommunicationReport;
        AVAILABLE_REPORTS.predictive.generator = generatePredictiveReport;
        
        Object.entries(selectedReports).forEach(([key, isSelected]) => {
            if (isSelected && AVAILABLE_REPORTS[key]) {
                reportsToGenerate.push(
                    AVAILABLE_REPORTS[key].generator(startDate, endDate, pirId)
                );
                reportTitles.push(AVAILABLE_REPORTS[key].name);
            }
        });
        
        if (reportsToGenerate.length === 0) {
            throw new Error('No reports selected for weekly emails');
        }
        
        console.log(`ðŸ“Š Generating ${reportsToGenerate.length} reports...`);
        const reportsData = await Promise.all(reportsToGenerate);
        
        console.log('ðŸ“„ Creating PDFs and uploading to Google Drive...');
        const driveLinks = [];
        
        for (let i = 0; i < reportsData.length; i++) {
            try {
                console.log(`\nðŸ“„ Processing ${i + 1}/${reportsData.length}: ${reportTitles[i]}`);
                
                const pdfBlob = await exportReportToPDFBlob(reportsData[i], reportTitles[i]);
                
                const fileName = `${pirData.displayName || pirData.email}_${reportTitles[i]}_${dateStamp}.pdf`;
                
                const driveFile = await uploadPDFToDrive(
                    pdfBlob,
                    fileName,
                    pirData.displayName || pirData.email,
                    'weekly',
                    user.googleAccessToken
                );
                
                driveLinks.push({
                    title: reportTitles[i],
                    url: driveFile.webViewLink
                });
                
                console.log(`âœ… Uploaded: ${reportTitles[i]}`);
                
            } catch (error) {
                console.error(`âŒ Failed ${reportTitles[i]}:`, error);
            }
        }
        
        if (driveLinks.length === 0) {
            throw new Error('Failed to generate any reports');
        }
        
        console.log(`ðŸ“§ Sending email with ${driveLinks.length} Drive links...`);
        
        const emailHtml = getEmailTemplateWithDynamicLinks(
            pirData.displayName || pirData.email,
            'weekly',
            dateRange,
            driveLinks
        );
        
        await db.collection('mail').add({
            to: [pirData.email],
            message: {
                subject: `Weekly Progress Reports - ${dateRange}`,
                html: emailHtml
            }
        });
        
        console.log(`âœ… Weekly reports complete: ${driveLinks.length}/${reportsToGenerate.length} sent to ${pirData.email}`);
        return { 
            success: driveLinks.length === reportsToGenerate.length, 
            pirEmail: pirData.email, 
            sentCount: driveLinks.length,
            expectedCount: reportsToGenerate.length
        };
        
    } catch (error) {
        console.error('âŒ Error sending weekly reports:', error);
        throw error;
    }
};

// ========== SEND MONTHLY PROGRESS REPORTS (DYNAMIC BASED ON SELECTED REPORTS) ==========
const sendMonthlyProgressReport = async (pirId) => {
    try {
        console.log(`ðŸ“§ Generating monthly reports for PIR: ${pirId}`);
        
        // âœ… Check & refresh token before using
        await checkAndRefreshGoogleToken();
        console.log('âœ… Token validated, proceeding with monthly reports...');
        
        const pirDoc = await db.collection('users').doc(pirId).get();
        if (!pirDoc.exists) {
            throw new Error('PIR not found');
        }
        const pirData = pirDoc.data();
        
        let coachName = 'Your Recovery Coach';
        if (pirData.assignedCoach) {
            const coachDoc = await db.collection('users').doc(pirData.assignedCoach).get();
            if (coachDoc.exists) {
                coachName = coachDoc.data().displayName || coachName;
            }
        }
        
        const endDate = new Date();
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - 29);
        
        const dateRange = startDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
        const dateStamp = endDate.toISOString().split('T')[0];
        
        // âœ… DYNAMICALLY BUILD REPORT LIST BASED ON SELECTED REPORTS
        const reportsToGenerate = [];
        const reportTitles = [];
        
        // Set generator functions (they're defined later in the code)
        AVAILABLE_REPORTS.morningCheckins.generator = generateMorningCheckinsReport;
        AVAILABLE_REPORTS.eveningReflections.generator = generateEveningReflectionsReport;
        AVAILABLE_REPORTS.moodAnalysis.generator = generateMoodAnalysisReport;
        AVAILABLE_REPORTS.overview.generator = generateOverviewReport;
        AVAILABLE_REPORTS.sobriety.generator = generateSobrietyReport;
        AVAILABLE_REPORTS.engagement.generator = generateEngagementReport;
        AVAILABLE_REPORTS.milestones.generator = generateMilestonesReport;
        AVAILABLE_REPORTS.crisis.generator = generateCrisisReport;
        AVAILABLE_REPORTS.communication.generator = generateCommunicationReport;
        AVAILABLE_REPORTS.predictive.generator = generatePredictiveReport;
        
        Object.entries(selectedReports).forEach(([key, isSelected]) => {
            if (isSelected && AVAILABLE_REPORTS[key]) {
                reportsToGenerate.push(
                    AVAILABLE_REPORTS[key].generator(startDate, endDate, pirId)
                );
                reportTitles.push(AVAILABLE_REPORTS[key].name);
            }
        });
        
        if (reportsToGenerate.length === 0) {
            throw new Error('No reports selected for monthly emails');
        }
        
        console.log(`ðŸ“Š Generating ${reportsToGenerate.length} reports...`);
        const reportsData = await Promise.all(reportsToGenerate);
        
        console.log('ðŸ“„ Creating PDFs and uploading to Google Drive...');
        const driveLinks = [];
        
        for (let i = 0; i < reportsData.length; i++) {
            try {
                console.log(`\nðŸ“„ Processing ${i + 1}/${reportsData.length}: ${reportTitles[i]}`);
                
                const pdfBlob = await exportReportToPDFBlob(reportsData[i], reportTitles[i]);
                
                const fileName = `${pirData.displayName || pirData.email}_${reportTitles[i]}_${dateStamp}.pdf`;
                
                const driveFile = await uploadPDFToDrive(
                    pdfBlob,
                    fileName,
                    pirData.displayName || pirData.email,
                    'monthly',
                    user.googleAccessToken
                );
                
                driveLinks.push({
                    title: reportTitles[i],
                    url: driveFile.webViewLink
                });
                
                console.log(`âœ… Uploaded: ${reportTitles[i]}`);
                
            } catch (error) {
                console.error(`âŒ Failed ${reportTitles[i]}:`, error);
            }
        }
        
        if (driveLinks.length === 0) {
            throw new Error('Failed to generate any reports');
        }
        
        console.log(`ðŸ“§ Sending email with ${driveLinks.length} Drive links...`);
        
        const emailHtml = getEmailTemplateWithDynamicLinks(
            pirData.displayName || pirData.email,
            'monthly',
            dateRange,
            driveLinks
        );
        
        await db.collection('mail').add({
            to: [pirData.email],
            message: {
                subject: `Monthly Progress Reports - ${dateRange}`,
                html: emailHtml
            }
        });
        
        console.log(`âœ… Monthly reports complete: ${driveLinks.length}/${reportsToGenerate.length} sent to ${pirData.email}`);
        return { 
            success: driveLinks.length === reportsToGenerate.length, 
            pirEmail: pirData.email, 
            sentCount: driveLinks.length,
            expectedCount: reportsToGenerate.length
        };
        
    } catch (error) {
        console.error('âŒ Error sending monthly reports:', error);
        throw error;
    }
};
// ========== SEND ALL WEEKLY REPORTS ==========
const sendAllWeeklyReports = async () => {
    try {
        // âœ… CHECK IF AUTOMATION IS ENABLED
        if (!automationEnabled) {
            console.log('âš ï¸ Automation is disabled. Skipping weekly reports.');
            alert('âš ï¸ Automation is currently disabled. Enable it in the configuration to send reports.');
            return [];
        }
        
        console.log('ðŸ“§ Sending weekly reports to all PIRs...');
        
        const pirsSnapshot = await db.collection('users')
            .where('role', '==', 'pir')
            .where('active', '==', true)
            .get();
        
        const results = [];
        
        for (const pirDoc of pirsSnapshot.docs) {
            try {
                const result = await sendWeeklyProgressReport(pirDoc.id);
                results.push({ pirId: pirDoc.id, ...result });
            } catch (error) {
                console.error(`Failed to send weekly reports to ${pirDoc.id}:`, error);
                results.push({ pirId: pirDoc.id, success: false, error: error.message });
            }
        }
        
        const successCount = results.filter(r => r.success).length;
        console.log(`âœ… Weekly reports sent: ${successCount}/${results.length}`);
        
        // Update last run status
        setLastRunStatus(prev => ({
            ...prev,
            weekly: {
                timestamp: new Date().toISOString(),
                pirCount: results.length,
                successCount,
                success: successCount === results.length
            }
        }));
        
        // Save to Firebase
        await db.collection('automationConfig').doc(user.uid).update({
            'lastRunStatus.weekly': {
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                pirCount: results.length,
                successCount,
                success: successCount === results.length
            }
        });
        
        alert(`âœ… Weekly reports sent to ${successCount} out of ${results.length} PIRs`);
        return results;
        
    } catch (error) {
        console.error('âŒ Error sending weekly reports:', error);
        alert('Error sending weekly reports. Check console for details.');
        throw error;
    }
};
// ========== SEND ALL MONTHLY REPORTS ==========
const sendAllMonthlyReports = async () => {
    try {
        // âœ… CHECK IF AUTOMATION IS ENABLED
        if (!automationEnabled) {
            console.log('âš ï¸ Automation is disabled. Skipping monthly reports.');
            alert('âš ï¸ Automation is currently disabled. Enable it in the configuration to send reports.');
            return [];
        }
        
        console.log('ðŸ“§ Sending monthly reports to all PIRs...');
        
        const pirsSnapshot = await db.collection('users')
            .where('role', '==', 'pir')
            .where('active', '==', true)
            .get();
        
        const results = [];
        
        for (const pirDoc of pirsSnapshot.docs) {
            try {
                const result = await sendMonthlyProgressReport(pirDoc.id);
                results.push({ pirId: pirDoc.id, ...result });
            } catch (error) {
                console.error(`Failed to send monthly reports to ${pirDoc.id}:`, error);
                results.push({ pirId: pirDoc.id, success: false, error: error.message });
            }
        }
        
        const successCount = results.filter(r => r.success).length;
        console.log(`âœ… Monthly reports sent: ${successCount}/${results.length}`);
        
        // Update last run status
        setLastRunStatus(prev => ({
            ...prev,
            monthly: {
                timestamp: new Date().toISOString(),
                pirCount: results.length,
                successCount,
                success: successCount === results.length
            }
        }));
        
        // Save to Firebase
        await db.collection('automationConfig').doc(user.uid).update({
            'lastRunStatus.monthly': {
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                pirCount: results.length,
                successCount,
                success: successCount === results.length
            }
        });
        
        alert(`âœ… Monthly reports sent to ${successCount} out of ${results.length} PIRs`);
        return results;
        
    } catch (error) {
        console.error('âŒ Error sending monthly reports:', error);
        alert('Error sending monthly reports. Check console for details.');
        throw error;
    }
};
    // ========== UTILITY FUNCTIONS ==========
    const formatDate = (date) => {
        if (!date) return '-';
        const d = date.toDate ? date.toDate() : new Date(date);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
    };

    const formatDateTime = (date) => {
        if (!date) return '-';
        const d = date.toDate ? date.toDate() : new Date(date);
        return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' ' +
               d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
    };

    const formatTimeAgo = (date) => {
        if (!date) return '-';
        const d = date.toDate ? date.toDate() : new Date(date);
        const seconds = Math.floor((new Date() - d) / 1000);
        if (seconds < 60) return 'Just now';
        if (seconds < 3600) return Math.floor(seconds / 60) + ' min ago';
        if (seconds < 86400) return Math.floor(seconds / 3600) + ' hr ago';
        return Math.floor(seconds / 86400) + ' days ago';
    };

    const exportToJSON = (data, filename) => {
        const jsonStr = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    };

    const exportToCSV = (data, filename) => {
        if (!data || data.length === 0) return;
        
        const headers = Object.keys(data[0]);
        const csvContent = [
            headers.join(','),
            ...data.map(row => headers.map(header => {
                const value = row[header]?.toString() || '';
                return value.includes(',') ? `"${value}"` : value;
            }).join(','))
        ].join('\n');
        
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}_${new Date().toISOString().split('T')[0]}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // ========== ANALYTICS CALCULATION ==========
    const calculateAnalytics = () => {
        const pirStats = {};
        const allPIRsData = {
            totalCheckIns: allCheckIns.length,
            avgMood: 0,
            avgCraving: 0,
            avgAnxiety: 0,
            avgSleep: 0,
            completionRate: 0,
            last30Days: {
                avgMood: 0,
                avgCraving: 0,
                avgAnxiety: 0,
                avgSleep: 0,
                completionRate: 0
            }
        };

        const thirtyDaysAgo = new Date();
        thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

        allCheckIns.forEach(checkIn => {
            if (!pirStats[checkIn.userId]) {
                pirStats[checkIn.userId] = {
                    userName: checkIn.userName,
                    userId: checkIn.userId,
                    totalCheckIns: 0,
                    completeCheckIns: 0,
                    moodSum: 0,
                    moodCount: 0,
                    cravingSum: 0,
                    cravingCount: 0,
                    anxietySum: 0,
                    anxietyCount: 0,
                    sleepSum: 0,
                    sleepCount: 0,
                    last30: {
                        totalCheckIns: 0,
                        completeCheckIns: 0,
                        moodSum: 0,
                        moodCount: 0,
                        cravingSum: 0,
                        cravingCount: 0,
                        anxietySum: 0,
                        anxietyCount: 0,
                        sleepSum: 0,
                        sleepCount: 0
                    }
                };
            }

            const stat = pirStats[checkIn.userId];
            const checkInDate = checkIn.createdAt?.toDate ? checkIn.createdAt.toDate() : new Date(checkIn.createdAt);
            const isLast30 = checkInDate >= thirtyDaysAgo;

            stat.totalCheckIns++;
            const hasMorning = checkIn.morningData && Object.keys(checkIn.morningData).length > 0;
            const hasEvening = checkIn.eveningData && Object.keys(checkIn.eveningData).length > 0;
            if (hasMorning && hasEvening) stat.completeCheckIns++;

            if (checkIn.morningData?.mood != null) {
                stat.moodSum += checkIn.morningData.mood;
                stat.moodCount++;
            }
            if (checkIn.morningData?.craving != null) {
                stat.cravingSum += checkIn.morningData.craving;
                stat.cravingCount++;
            }
            if (checkIn.morningData?.anxietyLevel != null) {
                stat.anxietySum += checkIn.morningData.anxietyLevel;
                stat.anxietyCount++;
            }
            if (checkIn.morningData?.sleepQuality != null) {
                stat.sleepSum += checkIn.morningData.sleepQuality;
                stat.sleepCount++;
            }

            if (isLast30) {
                stat.last30.totalCheckIns++;
                if (hasMorning && hasEvening) stat.last30.completeCheckIns++;
                
                if (checkIn.morningData?.mood != null) {
                    stat.last30.moodSum += checkIn.morningData.mood;
                    stat.last30.moodCount++;
                }
                if (checkIn.morningData?.craving != null) {
                    stat.last30.cravingSum += checkIn.morningData.craving;
                    stat.last30.cravingCount++;
                }
                if (checkIn.morningData?.anxietyLevel != null) {
                    stat.last30.anxietySum += checkIn.morningData.anxietyLevel;
                    stat.last30.anxietyCount++;
                }
                if (checkIn.morningData?.sleepQuality != null) {
                    stat.last30.sleepSum += checkIn.morningData.sleepQuality;
                    stat.last30.sleepCount++;
                }
            }
        });

        Object.values(pirStats).forEach(stat => {
            stat.avgMood = stat.moodCount > 0 ? (stat.moodSum / stat.moodCount).toFixed(1) : 'N/A';
            stat.avgCraving = stat.cravingCount > 0 ? (stat.cravingSum / stat.cravingCount).toFixed(1) : 'N/A';
            stat.avgAnxiety = stat.anxietyCount > 0 ? (stat.anxietySum / stat.anxietyCount).toFixed(1) : 'N/A';
            stat.avgSleep = stat.sleepCount > 0 ? (stat.sleepSum / stat.sleepCount).toFixed(1) : 'N/A';
            stat.completionRate = stat.totalCheckIns > 0 ? Math.round((stat.completeCheckIns / stat.totalCheckIns) * 100) : 0;

            stat.last30.avgMood = stat.last30.moodCount > 0 ? (stat.last30.moodSum / stat.last30.moodCount).toFixed(1) : 'N/A';
            stat.last30.avgCraving = stat.last30.cravingCount > 0 ? (stat.last30.cravingSum / stat.last30.cravingCount).toFixed(1) : 'N/A';
            stat.last30.avgAnxiety = stat.last30.anxietyCount > 0 ? (stat.last30.anxietySum / stat.last30.anxietyCount).toFixed(1) : 'N/A';
            stat.last30.avgSleep = stat.last30.sleepCount > 0 ? (stat.last30.sleepSum / stat.last30.sleepCount).toFixed(1) : 'N/A';
            stat.last30.completionRate = stat.last30.totalCheckIns > 0 ? Math.round((stat.last30.completeCheckIns / stat.last30.totalCheckIns) * 100) : 0;
        });

        // Calculate all-PIRs aggregate
        let totalMood = 0, totalCraving = 0, totalAnxiety = 0, totalSleep = 0;
        let moodCount = 0, cravingCount = 0, anxietyCount = 0, sleepCount = 0;
        let completeCount = 0;
        let last30Mood = 0, last30Craving = 0, last30Anxiety = 0, last30Sleep = 0;
        let last30MoodCount = 0, last30CravingCount = 0, last30AnxietyCount = 0, last30SleepCount = 0;
        let last30Complete = 0, last30Total = 0;

        allCheckIns.forEach(checkIn => {
            const checkInDate = checkIn.createdAt?.toDate ? checkIn.createdAt.toDate() : new Date(checkIn.createdAt);
            const isLast30 = checkInDate >= thirtyDaysAgo;

            const hasMorning = checkIn.morningData && Object.keys(checkIn.morningData).length > 0;
            const hasEvening = checkIn.eveningData && Object.keys(checkIn.eveningData).length > 0;
            if (hasMorning && hasEvening) completeCount++;
            
            if (checkIn.morningData?.mood != null) {
                totalMood += checkIn.morningData.mood;
                moodCount++;
            }
            if (checkIn.morningData?.craving != null) {
                totalCraving += checkIn.morningData.craving;
                cravingCount++;
            }
            if (checkIn.morningData?.anxietyLevel != null) {
                totalAnxiety += checkIn.morningData.anxietyLevel;
                anxietyCount++;
            }
            if (checkIn.morningData?.sleepQuality != null) {
                totalSleep += checkIn.morningData.sleepQuality;
                sleepCount++;
            }

            if (isLast30) {
                last30Total++;
                if (hasMorning && hasEvening) last30Complete++;
                
                if (checkIn.morningData?.mood != null) {
                    last30Mood += checkIn.morningData.mood;
                    last30MoodCount++;
                }
                if (checkIn.morningData?.craving != null) {
                    last30Craving += checkIn.morningData.craving;
                    last30CravingCount++;
                }
                if (checkIn.morningData?.anxietyLevel != null) {
                    last30Anxiety += checkIn.morningData.anxietyLevel;
                    last30AnxietyCount++;
                }
                if (checkIn.morningData?.sleepQuality != null) {
                    last30Sleep += checkIn.morningData.sleepQuality;
                    last30SleepCount++;
                }
            }
        });

        allPIRsData.avgMood = moodCount > 0 ? (totalMood / moodCount).toFixed(1) : 'N/A';
        allPIRsData.avgCraving = cravingCount > 0 ? (totalCraving / cravingCount).toFixed(1) : 'N/A';
        allPIRsData.avgAnxiety = anxietyCount > 0 ? (totalAnxiety / anxietyCount).toFixed(1) : 'N/A';
        allPIRsData.avgSleep = sleepCount > 0 ? (totalSleep / sleepCount).toFixed(1) : 'N/A';
        allPIRsData.completionRate = allCheckIns.length > 0 ? Math.round((completeCount / allCheckIns.length) * 100) : 0;

        allPIRsData.last30Days.avgMood = last30MoodCount > 0 ? (last30Mood / last30MoodCount).toFixed(1) : 'N/A';
        allPIRsData.last30Days.avgCraving = last30CravingCount > 0 ? (last30Craving / last30CravingCount).toFixed(1) : 'N/A';
        allPIRsData.last30Days.avgAnxiety = last30AnxietyCount > 0 ? (last30Anxiety / last30AnxietyCount).toFixed(1) : 'N/A';
        allPIRsData.last30Days.avgSleep = last30SleepCount > 0 ? (last30Sleep / last30SleepCount).toFixed(1) : 'N/A';
        allPIRsData.last30Days.completionRate = last30Total > 0 ? Math.round((last30Complete / last30Total) * 100) : 0;

        setAnalyticsData({ pirStats, allPIRsData });
    };

 // ==========================================
// REPORT GENERATOR FUNCTIONS (ALL 12)
// ==========================================

// ========== REPORT GENERATOR 1: OVERVIEW ==========
const generateOverviewReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build queries with optional PIR filter
        let checkInsQuery = db.collection('checkIns')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        let assignmentsQuery = db.collection('assignments')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        let alertsQuery = db.collection('alerts')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        let goalsQuery = db.collection('goals');
        
        if (pirId) {
            checkInsQuery = checkInsQuery.where('userId', '==', pirId);
            assignmentsQuery = assignmentsQuery.where('userId', '==', pirId);
            alertsQuery = alertsQuery.where('userId', '==', pirId);
            goalsQuery = goalsQuery.where('userId', '==', pirId);
        }
        
        const [usersSnap, checkInsSnap, assignmentsSnap, alertsSnap, goalsSnap] = await Promise.all([
            db.collection('users').get(),
            checkInsQuery.get(),
            assignmentsQuery.get(),
            alertsQuery.get(),
            goalsQuery.get()
        ]);
        const pirs = usersSnap.docs.filter(doc => doc.data().role === 'pir');
        const checkIns = checkInsSnap.docs.map(doc => doc.data());

        // Calculate dates and metrics
        const dates = [];
        const moods = [];
        const cravings = [];
        const anxiety = [];
        const sleep = [];
        
        const current = new Date(start);
        while (current <= end) {
            const dayCheckIns = checkIns.filter(c => {
                const date = c.createdAt?.toDate ? c.createdAt.toDate() : new Date(c.createdAt);
                return date.toDateString() === current.toDateString();
            });
            
            dates.push(current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            
            if (dayCheckIns.length > 0) {
                moods.push(parseFloat((dayCheckIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / dayCheckIns.length).toFixed(1)));
                cravings.push(parseFloat((dayCheckIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / dayCheckIns.length).toFixed(1)));
                anxiety.push(parseFloat((dayCheckIns.reduce((sum, c) => sum + (c.morningData?.anxietyLevel || 0), 0) / dayCheckIns.length).toFixed(1)));
                sleep.push(parseFloat((dayCheckIns.reduce((sum, c) => sum + (c.morningData?.sleepQuality || 0), 0) / dayCheckIns.length).toFixed(1)));
            } else {
                moods.push(null);
                cravings.push(null);
                anxiety.push(null);
                sleep.push(null);
            }
            
            current.setDate(current.getDate() + 1);
        }

        const avgMood = checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length || 0;
        const avgCraving = checkIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / checkIns.length || 0;
        const avgAnxiety = checkIns.reduce((sum, c) => sum + (c.morningData?.anxietyLevel || 0), 0) / checkIns.length || 0;
        const avgSleep = checkIns.reduce((sum, c) => sum + (c.morningData?.sleepQuality || 0), 0) / checkIns.length || 0;

        // Calculate previous period for comparison
        const periodLength = Math.ceil((end - start) / (1000 * 60 * 60 * 24));
        const prevStart = new Date(start);
        prevStart.setDate(prevStart.getDate() - periodLength);
        const prevEnd = new Date(start);
        prevEnd.setDate(prevEnd.getDate() - 1);

        const prevCheckInsSnap = await db.collection('checkIns')
            .where('createdAt', '>=', prevStart)
            .where('createdAt', '<=', prevEnd)
            .get();

        const prevCheckIns = prevCheckInsSnap.docs.map(doc => doc.data());
        const prevAvgMood = prevCheckIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / prevCheckIns.length || 0;
        const prevAvgCraving = prevCheckIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / prevCheckIns.length || 0;

        const moodChange = avgMood - prevAvgMood;
        const cravingChange = avgCraving - prevAvgCraving;

        // Generate insights
        const insights = [];
        if (moodChange > 1) insights.push(`ðŸŽ‰ Mood improved ${moodChange.toFixed(1)} points - excellent progress!`);
        else if (moodChange < -1) insights.push(`âš ï¸ Mood decreased ${Math.abs(moodChange).toFixed(1)} points - reach out for support`);
        
        if (cravingChange < -1) insights.push(`âœ¨ Cravings decreased ${Math.abs(cravingChange).toFixed(1)} points - stay strong!`);
        else if (cravingChange > 1) insights.push(`âš ï¸ Cravings increased ${cravingChange.toFixed(1)} points - use coping strategies`);
        
        if (avgMood >= 7) insights.push('ðŸ’š Overall mood is in a healthy range this period');
        if (avgCraving <= 3) insights.push('ðŸŒŸ Cravings are well-managed - keep up the great work!');
        if (insights.length === 0) insights.push('ðŸ“Š Continue building positive momentum in your recovery');

        const completedAssignments = assignmentsSnap.docs.filter(d => d.data().status === 'completed').length;
        const assignmentRate = assignmentsSnap.size > 0 ? ((completedAssignments / assignmentsSnap.size) * 100).toFixed(0) : 0;

        return {
            type: 'overview',
            metadata: {
                title: 'Program Overview Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'overview'
            },
            summary: {
                totalPIRs: pirs.length,
                activePIRs: pirs.filter(p => p.data().active !== false).length,
                totalCheckIns: checkInsSnap.size,
                avgMood: parseFloat(avgMood.toFixed(1)),
                avgCravings: parseFloat(avgCraving.toFixed(1)),
                avgAnxiety: parseFloat(avgAnxiety.toFixed(1)),
                avgSleep: parseFloat(avgSleep.toFixed(1)),
                totalAssignments: assignmentsSnap.size,
                completedAssignments,
                assignmentRate: parseFloat(assignmentRate),
                totalAlerts: alertsSnap.size,
                sosAlerts: alertsSnap.docs.filter(d => d.data().type === 'sos').length,
                totalGoals: goalsSnap.size,
                completedGoals: goalsSnap.docs.filter(d => d.data().status === 'completed').length,
                moodChange: parseFloat(moodChange.toFixed(1)),
                cravingChange: parseFloat(cravingChange.toFixed(1))
            },
            insights,
            charts: {
                trends: { dates, moods, cravings, anxiety, sleep },
                distribution: calculateMoodDistribution(checkIns)
            },
            patterns: detectPatterns(checkIns)
        };
    } catch (error) {
        console.error('Error generating overview:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 2: SOBRIETY ==========
const generateSobrietyReport = async (start, end, pirId = null) => {
    // âœ… Build PIR query with optional filter
    let pirsQuery = db.collection('users').where('role', '==', 'pir');
    
    if (pirId) {
        pirsQuery = pirsQuery.where(firebase.firestore.FieldPath.documentId(), '==', pirId);
    }
    
    const pirsSnap = await pirsQuery.get();

    const sobrietyData = [];
    
    for (const pirDoc of pirsSnap.docs) {
        const pirData = pirDoc.data();
        if (!pirData.sobrietyDate) continue;

        const sobrietyDate = new Date(pirData.sobrietyDate);
        const daysSober = Math.floor((new Date() - sobrietyDate) / (1000 * 60 * 60 * 24));
        
        const checkInsSnap = await db.collection('checkIns')
            .where('userId', '==', pirDoc.id)
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end)
            .get();
       
        const checkIns = checkInsSnap.docs.map(doc => doc.data());
        const avgCravings = checkIns.length > 0 
            ? (checkIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / checkIns.length).toFixed(1)
            : 0;
        const avgMood = checkIns.length > 0
            ? (checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length).toFixed(1)
            : 0;

        const riskScore = calculateRiskScore(avgMood, avgCravings, daysSober);

        sobrietyData.push({
            pirName: pirData.displayName || pirData.email,
            pirId: pirDoc.id,
            daysSober,
            sobrietyDate: pirData.sobrietyDate,
            avgMood,
            avgCravings,
            riskScore,
            riskLevel: riskScore >= 7 ? 'Critical' : riskScore >= 4 ? 'High' : 'Moderate',
            checkInCount: checkIns.length
        });
    }

    return {
        type: 'sobriety',
        metadata: {
            title: 'Sobriety Analysis Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'sobriety'
        },
        sobrietyData: sobrietyData.sort((a, b) => b.daysSober - a.daysSober),
        summary: {
            totalPIRs: sobrietyData.length,
            avgDaysSober: (sobrietyData.reduce((sum, p) => sum + p.daysSober, 0) / sobrietyData.length).toFixed(0),
            criticalRisk: sobrietyData.filter(p => p.riskScore >= 7).length,
            highRisk: sobrietyData.filter(p => p.riskScore >= 4 && p.riskScore < 7).length,
            moderateRisk: sobrietyData.filter(p => p.riskScore < 4).length
        },
        charts: {
            riskDistribution: {
                labels: ['Moderate Risk', 'High Risk', 'Critical Risk'],
                data: [
                    sobrietyData.filter(p => p.riskScore < 4).length,
                    sobrietyData.filter(p => p.riskScore >= 4 && p.riskScore < 7).length,
                    sobrietyData.filter(p => p.riskScore >= 7).length
                ]
            },
            sobrietyVsCravings: {
                data: sobrietyData.map(p => ({
                    x: p.daysSober,
                    y: parseFloat(p.avgCravings) || 0
                }))
            }
        }
    };
};

// ========== REPORT GENERATOR 3: MORNING CHECK-INS ==========
const generateMorningCheckinsReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build query with optional PIR filter
        let checkInsQuery = db.collection('checkIns')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        if (pirId) {
            checkInsQuery = checkInsQuery.where('userId', '==', pirId);
        }
        
        const checkInsSnap = await checkInsQuery.get();

        const morningData = [];
        const checkIns = checkInsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const usersCache = {};
        for (const checkIn of checkIns) {
            if (checkIn.morningData) {
                if (!usersCache[checkIn.userId]) {
                    const userDoc = await db.collection('users').doc(checkIn.userId).get();
                    usersCache[checkIn.userId] = userDoc.exists ? userDoc.data()?.displayName || 'Unknown' : 'Unknown';
                }
                
                morningData.push({
                    pirName: usersCache[checkIn.userId],
                    date: checkIn.createdAt,
                    mood: checkIn.morningData.mood,
                    craving: checkIn.morningData.craving,
                    anxiety: checkIn.morningData.anxietyLevel,
                    sleep: checkIn.morningData.sleepQuality,
                    notes: checkIn.morningData.notes || ''
                });
            }
        }

        // Calculate trends over time
        const dates = [];
        const moods = [];
        const cravings = [];
        const anxiety = [];
        const sleep = [];
        
        const current = new Date(start);
        while (current <= end) {
            const dayData = morningData.filter(m => {
                const date = m.date?.toDate ? m.date.toDate() : new Date(m.date);
                return date.toDateString() === current.toDateString();
            });
            
            dates.push(current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            
            if (dayData.length > 0) {
                moods.push(parseFloat((dayData.reduce((sum, d) => sum + (d.mood || 0), 0) / dayData.length).toFixed(1)));
                cravings.push(parseFloat((dayData.reduce((sum, d) => sum + (d.craving || 0), 0) / dayData.length).toFixed(1)));
                anxiety.push(parseFloat((dayData.reduce((sum, d) => sum + (d.anxiety || 0), 0) / dayData.length).toFixed(1)));
                sleep.push(parseFloat((dayData.reduce((sum, d) => sum + (d.sleep || 0), 0) / dayData.length).toFixed(1)));
            } else {
                moods.push(null);
                cravings.push(null);
                anxiety.push(null);
                sleep.push(null);
            }
            
            current.setDate(current.getDate() + 1);
        }

        const avgMood = morningData.reduce((sum, c) => sum + (c.mood || 0), 0) / morningData.length || 0;
        const avgCravings = morningData.reduce((sum, c) => sum + (c.craving || 0), 0) / morningData.length || 0;
        const avgAnxiety = morningData.reduce((sum, c) => sum + (c.anxiety || 0), 0) / morningData.length || 0;
        const avgSleep = morningData.reduce((sum, c) => sum + (c.sleep || 0), 0) / morningData.length || 0;
        const withNotes = morningData.filter(m => m.notes && m.notes.length > 0).length;

        const insights = [];
        if (avgMood >= 7) insights.push('ðŸ’š Morning mood consistently positive');
        if (avgCravings <= 3) insights.push('ðŸŒŸ Cravings well-managed in mornings');
        if (avgSleep >= 7) insights.push('ðŸ˜´ Sleep quality is excellent');
        if (withNotes > morningData.length * 0.5) insights.push('ðŸ“ Great job adding notes to check-ins');

        return {
            type: 'morningCheckins',
            metadata: {
                title: 'Morning Check-ins Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'morningCheckins'
            },
            morningData,
            summary: {
                totalCheckIns: morningData.length,
                avgMood: parseFloat(avgMood.toFixed(1)),
                avgCravings: parseFloat(avgCravings.toFixed(1)),
                avgAnxiety: parseFloat(avgAnxiety.toFixed(1)),
                avgSleep: parseFloat(avgSleep.toFixed(1)),
                withNotes
            },
            insights,
            charts: {
                trends: { dates, moods, cravings, anxiety, sleep }
            }
        };
    } catch (error) {
        console.error('Error generating morning check-ins report:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 4: EVENING REFLECTIONS ==========
const generateEveningReflectionsReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build query with optional PIR filter
        let checkInsQuery = db.collection('checkIns')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        if (pirId) {
            checkInsQuery = checkInsQuery.where('userId', '==', pirId);
        }
        
        const checkInsSnap = await checkInsQuery.get();
        
        const eveningData = [];
        const checkIns = checkInsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        
        const usersCache = {};
        for (const checkIn of checkIns) {
            if (checkIn.eveningData) {
                if (!usersCache[checkIn.userId]) {
                    const userDoc = await db.collection('users').doc(checkIn.userId).get();
                    usersCache[checkIn.userId] = userDoc.exists ? userDoc.data()?.displayName || 'Unknown' : 'Unknown';
                }
                
                eveningData.push({
                    pirName: usersCache[checkIn.userId],
                    date: checkIn.createdAt,
                    overallDay: checkIn.eveningData.overallDay,
                    gratitude: checkIn.eveningData.gratitude || '',
                    challenges: checkIn.eveningData.challenges || '',
                    tomorrowGoal: checkIn.eveningData.tomorrowGoal || ''
                });
            }
        }
        
        const dates = [];
        const overallDayScores = [];
        
        const current = new Date(start);
        while (current <= end) {
            const dayData = eveningData.filter(e => {
                const date = e.date?.toDate ? e.date.toDate() : new Date(e.date);
                return date.toDateString() === current.toDateString();
            });
            
            dates.push(current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            
            if (dayData.length > 0) {
                const dayAvg = dayData.reduce((sum, d) => sum + (d.overallDay || 0), 0) / dayData.length;
                overallDayScores.push(parseFloat(dayAvg.toFixed(1)));
            } else {
                overallDayScores.push(null);
            }
            
            current.setDate(current.getDate() + 1);
        }
        
        const avgOverallDay = eveningData.reduce((sum, c) => sum + (c.overallDay || 0), 0) / eveningData.length || 0;
        const withGratitude = eveningData.filter(e => e.gratitude && e.gratitude.length > 0).length;
        const withChallenges = eveningData.filter(e => e.challenges && e.challenges.length > 0).length;
        const withGoals = eveningData.filter(e => e.tomorrowGoal && e.tomorrowGoal.length > 0).length;
        const completionRate = eveningData.length > 0 ? ((withGratitude + withChallenges + withGoals) / (eveningData.length * 3) * 100) : 0;
        
        const excellentDays = eveningData.filter(e => (e.overallDay || 0) >= 8).length;
        const goodDays = eveningData.filter(e => (e.overallDay || 0) >= 6 && (e.overallDay || 0) < 8).length;
        const challengingDays = eveningData.filter(e => (e.overallDay || 0) < 6).length;
        
        const insights = [];
        
        if (avgOverallDay >= 7) {
            insights.push('ðŸŽ‰ Overall day ratings are consistently positive');
        } else if (avgOverallDay >= 5) {
            insights.push('ðŸ“Š Day quality is moderate - identifying patterns can help');
        } else {
            insights.push('âš ï¸ Multiple challenging days - reach out for additional support');
        }
        
        const gratitudePercent = ((withGratitude / eveningData.length) * 100).toFixed(0);
        if (withGratitude > eveningData.length * 0.8) {
            insights.push(`ðŸ’š Excellent gratitude practice - ${gratitudePercent}% completion`);
        } else if (withGratitude > eveningData.length * 0.5) {
            insights.push(`ðŸŒŸ Good gratitude engagement - ${gratitudePercent}% completion`);
        }
        
        if (withGoals > eveningData.length * 0.7) {
            insights.push('ðŸŽ¯ Strong goal-setting habit - planning ahead consistently');
        }
        
        if (excellentDays > eveningData.length * 0.4) {
            insights.push(`âœ¨ ${excellentDays} excellent days (8+ rating) - great progress!`);
        }
        
        if (insights.length === 0) {
            insights.push('ðŸ“ Continue building your evening reflection practice');
        }
        
        return {
            type: 'eveningReflections',
            metadata: {
                title: 'Evening Reflections Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'eveningReflections'
            },
            eveningData,
            summary: {
                totalReflections: eveningData.length,
                avgOverallDay: parseFloat(avgOverallDay.toFixed(1)),
                withGratitude,
                withChallenges,
                withGoals,
                completionRate: parseFloat(completionRate.toFixed(1)),
                excellentDays,
                goodDays,
                challengingDays,
                gratitudePercent: parseFloat(gratitudePercent)
            },
            insights,
            charts: {
                trends: { dates, overallDayScores },
                dayQualityDistribution: {
                    labels: ['Excellent (8-10)', 'Good (6-7)', 'Challenging (1-5)'],
                    data: [excellentDays, goodDays, challengingDays]
                },
                completionBreakdown: {
                    labels: ['Gratitude', 'Challenges', 'Tomorrow Goals'],
                    data: [withGratitude, withChallenges, withGoals]
                }
            }
        };
    } catch (error) {
        console.error('Error generating evening reflections report:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 5: FULL PIR ==========
const generateFullPIRReport = async (start, end) => {
    const pirId = customConfig.selectedPIRs[0];
    if (!pirId) {
        alert('Please select a PIR for Full PIR Report');
        return {};
    }

    const pirDoc = await db.collection('users').doc(pirId).get();
    const pirData = pirDoc.data();

    const [checkInsSnap, goalsSnap, assignmentsSnap, alertsSnap] = await Promise.all([
        db.collection('checkIns').where('userId', '==', pirId)
            .where('createdAt', '>=', start).where('createdAt', '<=', end).get(),
        db.collection('goals').where('userId', '==', pirId).get(),
        db.collection('assignments').where('userId', '==', pirId)
            .where('createdAt', '>=', start).where('createdAt', '<=', end).get(),
        db.collection('alerts').where('userId', '==', pirId)
            .where('createdAt', '>=', start).where('createdAt', '<=', end).get()
    ]);

    const checkIns = checkInsSnap.docs.map(doc => doc.data());
    const goals = goalsSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    const assignments = assignmentsSnap.docs.map(doc => doc.data());
    const alerts = alertsSnap.docs.map(doc => doc.data());

    const sobrietyDays = pirData.sobrietyDate 
        ? Math.floor((new Date() - new Date(pirData.sobrietyDate)) / (1000 * 60 * 60 * 24))
        : 0;

    return {
        type: 'fullPIR',
        metadata: {
            title: 'Full PIR Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'fullPIR'
        },
        pirInfo: {
            name: pirData.displayName || pirData.email,
            email: pirData.email,
            sobrietyDate: pirData.sobrietyDate,
            daysSober: sobrietyDays
        },
        checkIns: {
            total: checkIns.length,
            avgMood: (checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length).toFixed(1),
            avgCravings: (checkIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / checkIns.length).toFixed(1)
        },
        goals: {
            total: goals.length,
            completed: goals.filter(g => g.status === 'completed').length,
            active: goals.filter(g => g.status === 'active').length
        },
        assignments: {
            total: assignments.length,
            completed: assignments.filter(a => a.status === 'completed').length
        },
        alerts: {
            total: alerts.length,
            sos: alerts.filter(a => a.type === 'sos').length
        },
        charts: {
            goalCompletion: {
                labels: ['Active', 'Completed'],
                data: [
                    goals.filter(g => g.status === 'active').length,
                    goals.filter(g => g.status === 'completed').length
                ]
            }
        }
    };
};

// ========== REPORT GENERATOR 6: MOOD ANALYSIS ==========
const generateMoodAnalysisReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build query with optional PIR filter
        let checkInsQuery = db.collection('checkIns')
            .where('createdAt', '>=', start)
            .where('createdAt', '<=', end);
        
        if (pirId) {
            checkInsQuery = checkInsQuery.where('userId', '==', pirId);
        }
        
        const checkInsSnap = await checkInsQuery.get();
        const checkIns = checkInsSnap.docs.map(doc => doc.data());
        
        const moodDistribution = Array(10).fill(0);
        checkIns.forEach(checkIn => {
            const mood = checkIn.morningData?.mood;
            if (mood >= 1 && mood <= 10) {
                moodDistribution[mood - 1]++;
            }
        });

        const avgMood = checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length || 0;
        const highMoodDays = checkIns.filter(c => (c.morningData?.mood || 0) >= 7).length;
        const lowMoodDays = checkIns.filter(c => (c.morningData?.mood || 0) <= 3).length;
        const moderateMoodDays = checkIns.filter(c => {
            const mood = c.morningData?.mood || 0;
            return mood > 3 && mood < 7;
        }).length;

        const dates = [];
        const moods = [];
        const current = new Date(start);
        
        while (current <= end) {
            const dayCheckIns = checkIns.filter(c => {
                const date = c.createdAt?.toDate ? c.createdAt.toDate() : new Date(c.createdAt);
                return date.toDateString() === current.toDateString();
            });
            
            dates.push(current.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            
            if (dayCheckIns.length > 0) {
                const dayAvg = dayCheckIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / dayCheckIns.length;
                moods.push(parseFloat(dayAvg.toFixed(1)));
            } else {
                moods.push(null);
            }
            
            current.setDate(current.getDate() + 1);
        }

        const insights = [];
        const healthyPercentage = ((highMoodDays / checkIns.length) * 100).toFixed(0);
        const concerningPercentage = ((lowMoodDays / checkIns.length) * 100).toFixed(0);

        if (highMoodDays > checkIns.length * 0.6) {
            insights.push(`ðŸŽ‰ ${healthyPercentage}% of days in healthy mood range (7-10)`);
        }
        if (lowMoodDays > checkIns.length * 0.3) {
            insights.push(`âš ï¸ ${concerningPercentage}% of days in low mood range - consider additional support`);
        }
        if (avgMood >= 7) {
            insights.push('ðŸ’š Overall mood average is excellent');
        } else if (avgMood >= 5) {
            insights.push('ðŸ“Š Mood is in moderate range - opportunities for improvement');
        } else {
            insights.push('âš ï¸ Mood average below target - reach out to your recovery coach');
        }

        return {
            type: 'moodAnalysis',
            metadata: {
                title: 'Mood Analysis Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'moodAnalysis'
            },
            summary: {
                avgMood: parseFloat(avgMood.toFixed(1)),
                highMoodDays,
                moderateMoodDays,
                lowMoodDays,
                totalCheckIns: checkIns.length,
                healthyPercentage: parseFloat(healthyPercentage),
                concerningPercentage: parseFloat(concerningPercentage)
            },
            insights,
            charts: {
                distribution: moodDistribution,
                trends: { dates, moods }
            }
        };
    } catch (error) {
        console.error('Error generating mood analysis:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 7: CRISIS ==========
const generateCrisisReport = async (start, end, pirId = null) => {
    // âœ… Build query with optional PIR filter
    let alertsQuery = db.collection('alerts')
        .where('createdAt', '>=', start)
        .where('createdAt', '<=', end);
    
    if (pirId) {
        alertsQuery = alertsQuery.where('userId', '==', pirId);
    }
    
    const alertsSnap = await alertsQuery.get();
    const alerts = [];
    for (const doc of alertsSnap.docs) {
        const alert = doc.data();
        const userDoc = await db.collection('users').doc(alert.userId).get();
        alerts.push({
            ...alert,
            pirName: userDoc.data()?.displayName || 'Unknown',
            id: doc.id
        });
    }

    const avgResponseTime = calculateAvgResponseTime(alerts.filter(a => a.resolved));

    return {
        type: 'crisis',
        metadata: {
            title: 'Crisis & Intervention Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'crisis'
        },
        alerts,
        summary: {
            totalAlerts: alerts.length,
            sosCount: alerts.filter(a => a.type === 'sos').length,
            resolved: alerts.filter(a => a.resolved).length,
            unresolved: alerts.filter(a => !a.resolved).length,
            criticalPriority: alerts.filter(a => a.priority === 'critical').length,
            avgResponseTime
        }
    };
};

// ========== REPORT GENERATOR 8: ENGAGEMENT ==========
const generateEngagementReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build PIR query with optional filter
        let pirsQuery = db.collection('users').where('role', '==', 'pir');
        
        if (pirId) {
            pirsQuery = pirsQuery.where(firebase.firestore.FieldPath.documentId(), '==', pirId);
        }
        
        const pirsSnap = await pirsQuery.get();
        
        const engagementData = [];
        
        for (const pirDoc of pirsSnap.docs) {
            const currentPirId = pirDoc.id;
            const pirData = pirDoc.data();
            
            const [checkInsSnap, assignmentsSnap, messagesSnap] = await Promise.all([
                db.collection('checkIns').where('userId', '==', currentPirId)
                    .where('createdAt', '>=', start).where('createdAt', '<=', end).get(),
                db.collection('assignments').where('userId', '==', currentPirId)
                    .where('createdAt', '>=', start).where('createdAt', '<=', end).get(),
                db.collection('messages').where('senderId', '==', currentPirId)
                    .where('createdAt', '>=', start).where('createdAt', '<=', end).get()
            ]);
            
            const checkIns = checkInsSnap.docs.map(d => d.data());
            const streak = calculateStreak(checkIns);
            
            const assignments = assignmentsSnap.docs.map(d => d.data());
            const assignmentCompletion = assignments.length > 0 
                ? ((assignments.filter(a => a.status === 'completed').length / assignments.length) * 100).toFixed(0)
                : 0;
            
            const engagementScore = calculateEngagementScore(
                checkInsSnap.size, 
                assignmentCompletion, 
                messagesSnap.size
            );
            
            engagementData.push({
                pirName: pirData.displayName || pirData.email,
                checkInCount: checkInsSnap.size,
                checkInStreak: streak,
                assignmentCount: assignmentsSnap.size,
                assignmentCompletion: parseFloat(assignmentCompletion),
                messageCount: messagesSnap.size,
                engagementScore
            });
        }
        
        engagementData.sort((a, b) => b.engagementScore - a.engagementScore);
        
        const avgCheckIns = engagementData.reduce((sum, p) => sum + p.checkInCount, 0) / engagementData.length;
        const avgCompletion = engagementData.reduce((sum, p) => sum + p.assignmentCompletion, 0) / engagementData.length;
        const highEngagement = engagementData.filter(p => p.engagementScore >= 75).length;
        const lowEngagement = engagementData.filter(p => p.engagementScore < 50).length;
        
        const insights = [];
        const highEngagementPercent = ((highEngagement / engagementData.length) * 100).toFixed(0);
        
        if (highEngagement > engagementData.length * 0.5) {
            insights.push(`ðŸŽ‰ ${highEngagementPercent}% of PIRs have high engagement (75+)`);
        }
        if (lowEngagement > engagementData.length * 0.3) {
            insights.push(`âš ï¸ ${lowEngagement} PIRs need engagement support`);
        }
        if (avgCheckIns >= 5) {
            insights.push(`ðŸ’š Strong check-in activity - average ${avgCheckIns.toFixed(1)} per PIR`);
        }
        
        return {
            type: 'engagement',
            metadata: {
                title: 'Engagement Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'engagement'
            },
            engagementData,
            summary: {
                avgCheckIns: parseFloat(avgCheckIns.toFixed(1)),
                avgCompletion: parseFloat(avgCompletion.toFixed(0)),
                highEngagement,
                lowEngagement,
                totalPIRs: engagementData.length
            },
            insights,
            charts: {
                engagementDistribution: {
                    labels: engagementData.map(e => e.pirName),
                    data: engagementData.map(e => e.engagementScore)
                }
            }
        };
    } catch (error) {
        console.error('Error generating engagement report:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 9: COMPARATIVE ==========
const generateComparativeReport = async (start, end) => {
    const pirId = customConfig.selectedPIRs[0];
    if (!pirId) {
        alert('Please select a PIR for Comparative Report');
        return {};
    }

    const pirDoc = await db.collection('users').doc(pirId).get();
    const pirData = pirDoc.data();

    const [pirCheckIns, allCheckIns] = await Promise.all([
        db.collection('checkIns').where('userId', '==', pirId)
            .where('createdAt', '>=', start).where('createdAt', '<=', end).get(),
        db.collection('checkIns')
            .where('createdAt', '>=', start).where('createdAt', '<=', end).get()
    ]);

    const pirStats = calculateStats(pirCheckIns.docs.map(d => d.data()));
    const programStats = calculateStats(allCheckIns.docs.map(d => d.data()));

    const sobrietyDays = pirData.sobrietyDate 
        ? Math.floor((new Date() - new Date(pirData.sobrietyDate)) / 86400000)
        : 0;

    return {
        type: 'comparative',
        metadata: {
            title: 'Comparative Analysis Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'comparative'
        },
        pirInfo: {
            name: pirData.displayName || pirData.email,
            daysSober: sobrietyDays
        },
        comparison: {
            avgMood: { pir: pirStats.avgMood, program: programStats.avgMood },
            avgCravings: { pir: pirStats.avgCravings, program: programStats.avgCravings },
            avgAnxiety: { pir: pirStats.avgAnxiety, program: programStats.avgAnxiety },
            avgSleep: { pir: pirStats.avgSleep, program: programStats.avgSleep }
        }
    };
};

// ========== REPORT GENERATOR 10: MILESTONES ==========
const generateMilestonesReport = async (start, end, pirId = null) => {
    try {
        // âœ… Build queries with optional PIR filter
        let goalsQuery = db.collection('goals').where('status', '==', 'completed');
        let milestonesQuery = db.collection('milestones').where('achieved', '==', true);
        
        if (pirId) {
            goalsQuery = goalsQuery.where('userId', '==', pirId);
            milestonesQuery = milestonesQuery.where('userId', '==', pirId);
        }
        
        const [goalsSnap, milestonesSnap] = await Promise.all([
            goalsQuery.get(),
            milestonesQuery.get()
        ]);
        
        const completedGoals = goalsSnap.docs
            .map(doc => ({ id: doc.id, ...doc.data() }))
            .filter(g => {
                const completedDate = g.completedAt?.toDate ? g.completedAt.toDate() : new Date(g.completedAt);
                return completedDate >= start && completedDate <= end;
            });
        
        const achievements = [];
        const usersCache = {};
        
        for (const goal of completedGoals) {
            if (!usersCache[goal.userId]) {
                const userDoc = await db.collection('users').doc(goal.userId).get();
                usersCache[goal.userId] = userDoc.exists ? userDoc.data()?.displayName || 'Unknown' : 'Unknown';
            }
            
            achievements.push({
                pirName: usersCache[goal.userId],
                type: 'goal',
                title: goal.title,
                completedAt: goal.completedAt,
                category: goal.category || 'general',
                description: goal.description || ''
            });
        }
        
        const achievedMilestones = milestonesSnap.docs
            .map(doc => ({ id: doc.id, ...doc.data() }))
            .filter(m => {
                const achievedDate = m.achievedAt?.toDate ? m.achievedAt.toDate() : new Date(m.achievedAt);
                return achievedDate >= start && achievedDate <= end;
            });
        
        for (const milestone of achievedMilestones) {
            if (!usersCache[milestone.userId]) {
                const userDoc = await db.collection('users').doc(milestone.userId).get();
                usersCache[milestone.userId] = userDoc.exists ? userDoc.data()?.displayName || 'Unknown' : 'Unknown';
            }
            
            achievements.push({
                pirName: usersCache[milestone.userId],
                type: 'milestone',
                title: milestone.title,
                completedAt: milestone.achievedAt,
                category: milestone.type || 'sobriety',
                description: milestone.description || ''
            });
        }
        
        achievements.sort((a, b) => {
            const dateA = a.completedAt?.toDate ? a.completedAt.toDate() : new Date(a.completedAt);
            const dateB = b.completedAt?.toDate ? b.completedAt.toDate() : new Date(b.completedAt);
            return dateB - dateA;
        });
        
        const sobrietyMilestones = await getSobrietyMilestones(start, end);
        
        const insights = [];
        const totalAchievements = achievements.length;
        
        if (totalAchievements > 10) {
            insights.push(`ðŸŽ‰ ${totalAchievements} achievements unlocked this period!`);
        } else if (totalAchievements > 0) {
            insights.push(`ðŸŒŸ ${totalAchievements} achievements completed`);
        }
        
        if (sobrietyMilestones.length > 0) {
            insights.push(`ðŸ† ${sobrietyMilestones.length} sobriety milestones reached`);
        }
        
        const uniquePIRs = [...new Set(achievements.map(a => a.pirName))].length;
        if (uniquePIRs > 0) {
            insights.push(`ðŸ’ª ${uniquePIRs} PIRs achieved milestones`);
        }
        
        return {
            type: 'milestones',
            metadata: {
                title: 'Milestones & Achievements Report',
                period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
                generatedAt: new Date().toLocaleString('en-US'),
                reportType: 'milestones'
            },
            achievements,
            sobrietyMilestones,
            summary: {
                totalAchievements: achievements.length,
                goalsCompleted: completedGoals.length,
                milestonesAchieved: achievedMilestones.length,
                sobrietyMilestones: sobrietyMilestones.length,
                uniquePIRs
            },
            insights
        };
    } catch (error) {
        console.error('Error generating milestones report:', error);
        throw error;
    }
};

// ========== REPORT GENERATOR 11: COMMUNICATION ==========
const generateCommunicationReport = async (start, end, pirId = null) => {
    // âœ… Build query with optional PIR filter
    let messagesQuery = db.collection('messages')
        .where('createdAt', '>=', start)
        .where('createdAt', '<=', end);
    
    if (pirId) {
        messagesQuery = messagesQuery.where('senderId', '==', pirId);
    }
    
    const messagesSnap = await messagesQuery.get();

    const pirMessages = {};
    const messages = messagesSnap.docs.map(doc => ({ id: doc.id, ...doc.data() }));

    messages.forEach(msg => {
        const userId = msg.senderId;
        if (!pirMessages[userId]) {
            pirMessages[userId] = { sent: 0, received: 0 };
        }
        pirMessages[userId].sent++;

        if (msg.recipientId && msg.recipientId !== userId) {
            if (!pirMessages[msg.recipientId]) {
                pirMessages[msg.recipientId] = { sent: 0, received: 0 };
            }
            pirMessages[msg.recipientId].received++;
        }
    });

    const pirComms = [];
    const usersCache = {};
    for (const [userId, counts] of Object.entries(pirMessages)) {
        if (!usersCache[userId]) {
            const userDoc = await db.collection('users').doc(userId).get();
            if (userDoc.exists && userDoc.data().role === 'pir') {
                usersCache[userId] = userDoc.data().displayName || userDoc.data().email;
                pirComms.push({
                    pirName: usersCache[userId],
                    messagesSent: counts.sent,
                    messagesReceived: counts.received
                });
            }
        }
    }

    return {
        type: 'communication',
        metadata: {
            title: 'Communication Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'communication'
        },
        pirComms: pirComms.sort((a, b) => b.messagesSent - a.messagesSent),
        summary: {
            totalMessages: messagesSnap.size,
            activeCommunicators: pirComms.filter(p => p.messagesSent >= 5).length,
            avgMessagesPerPIR: pirComms.length > 0 
                ? (pirComms.reduce((sum, p) => sum + p.messagesSent, 0) / pirComms.length).toFixed(1)
                : 0
        }
    };
};

// ========== REPORT GENERATOR 12: PREDICTIVE RISK ==========
const generatePredictiveReport = async (start, end, pirId = null) => {
    // âœ… Build PIR query with optional filter
    let pirsQuery = db.collection('users').where('role', '==', 'pir');
    
    if (pirId) {
        pirsQuery = pirsQuery.where(firebase.firestore.FieldPath.documentId(), '==', pirId);
    }
    
    const pirsSnap = await pirsQuery.get();

    const riskData = [];

    for (const pirDoc of pirsSnap.docs) {
        const currentPirId = pirDoc.id;
        const pirData = pirDoc.data();

        const checkInsSnap = await db.collection('checkIns')
            .where('userId', '==', currentPirId)
            .orderBy('createdAt', 'desc')
            .limit(7)
            .get();
        const recentCheckIns = checkInsSnap.docs.map(d => d.data());
        const patterns = detectPatternsForPIR(recentCheckIns);
        const riskScore = calculatePredictiveRisk(recentCheckIns, patterns, pirData);

        riskData.push({
            pirName: pirData.displayName || pirData.email,
            riskScore,
            riskLevel: riskScore >= 7 ? 'High' : riskScore >= 4 ? 'Moderate' : 'Low',
            patterns,
            recommendations: generateRecommendations(patterns, riskScore)
        });
    }

    return {
        type: 'predictive',
        metadata: {
            title: 'Predictive Risk Report',
            period: `${start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })} - ${end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' })}`,
            generatedAt: new Date().toLocaleString('en-US'),
            reportType: 'predictive'
        },
        riskData: riskData.sort((a, b) => b.riskScore - a.riskScore),
        summary: {
            highRisk: riskData.filter(r => r.riskScore >= 7).length,
            moderateRisk: riskData.filter(r => r.riskScore >= 4 && r.riskScore < 7).length,
            lowRisk: riskData.filter(r => r.riskScore < 4).length
        }
    };
};

// ==========================================
// HELPER FUNCTIONS FOR REPORTS
// ==========================================

const calculateMoodDistribution = (checkIns) => {
    const distribution = Array(10).fill(0);
    checkIns.forEach(c => {
        const mood = c.morningData?.mood;
        if (mood >= 1 && mood <= 10) {
            distribution[mood - 1]++;
        }
    });
    return distribution;
};

const calculateRiskScore = (avgMood, avgCravings, daysSober) => {
    let score = 0;
    if (avgMood <= 3) score += 3;
    else if (avgMood <= 5) score += 2;
    if (avgCravings >= 7) score += 4;
    else if (avgCravings >= 4) score += 2;
    if (daysSober < 30) score += 2;
    else if (daysSober < 90) score += 1;
    return Math.min(score, 10);
};

const detectPatterns = (checkIns) => {
    const patterns = [];
    const sorted = checkIns.sort((a, b) => {
        const dateA = a.createdAt?.toDate ? a.createdAt.toDate() : new Date(a.createdAt);
        const dateB = b.createdAt?.toDate ? b.createdAt.toDate() : new Date(b.createdAt);
        return dateB - dateA;
    });

    if (sorted.length >= 3) {
        const recent = sorted.slice(0, 3);
        const moods = recent.map(c => c.morningData?.mood || 0);
        
        if (moods[0] < moods[1] && moods[1] < moods[2]) {
            patterns.push({ type: 'declining-mood', message: 'Declining mood trend detected across program' });
        }

        const cravings = recent.map(c => c.morningData?.craving || 0);
        if (cravings.filter(c => c >= 7).length >= 2) {
            patterns.push({ type: 'high-cravings', message: 'Multiple PIRs reporting high cravings' });
        }
    }

    return patterns;
};

const detectPatternsForPIR = (checkIns) => {
    const patterns = [];
    
    if (checkIns.length < 3) return patterns;

    const moods = checkIns.map(c => c.morningData?.mood || 0);
    const cravings = checkIns.map(c => c.morningData?.craving || 0);

    if (moods.length >= 3 && moods[0] < moods[1] && moods[1] < moods[2]) {
        patterns.push('Declining mood trend');
    }

    if (cravings.length >= 3 && cravings[0] > cravings[1] && cravings[1] > cravings[2]) {
        patterns.push('Increasing cravings');
    }

    const anxieties = checkIns.map(c => c.morningData?.anxietyLevel || 0);
    if (anxieties.filter(a => a >= 7).length >= 3) {
        patterns.push('Persistent high anxiety');
    }

    const sleeps = checkIns.map(c => c.morningData?.sleepQuality || 0);
    if (sleeps.filter(s => s <= 3).length >= 3) {
        patterns.push('Poor sleep quality');
    }

    return patterns;
};

const calculateAvgResponseTime = (resolvedAlerts) => {
    if (resolvedAlerts.length === 0) return 'N/A';
    
    const times = resolvedAlerts.map(alert => {
        const created = alert.createdAt?.toDate ? alert.createdAt.toDate() : new Date(alert.createdAt);
        const resolved = alert.resolvedAt?.toDate ? alert.resolvedAt.toDate() : new Date(alert.resolvedAt);
        return resolved - created;
    });
    
    const avgTime = times.reduce((sum, t) => sum + t, 0) / times.length;
    const hours = Math.floor(avgTime / (1000 * 60 * 60));
    const minutes = Math.floor((avgTime % (1000 * 60 * 60)) / (1000 * 60));
    
    return `${hours}h ${minutes}m`;
};

const calculateStreak = (checkIns) => {
    if (checkIns.length === 0) return 0;
    
    const sortedDates = checkIns
        .map(c => {
            const date = c.createdAt?.toDate ? c.createdAt.toDate() : new Date(c.createdAt);
            return date.toDateString();
        })
        .filter((date, index, arr) => arr.indexOf(date) === index)
        .sort((a, b) => new Date(b) - new Date(a));

    let streak = 1;
    const today = new Date().toDateString();
    
    if (sortedDates[0] !== today && sortedDates[0] !== new Date(Date.now() - 86400000).toDateString()) {
        return 0;
    }

    for (let i = 1; i < sortedDates.length; i++) {
        const prevDate = new Date(sortedDates[i - 1]);
        const currDate = new Date(sortedDates[i]);
        const diffDays = Math.floor((prevDate - currDate) / 86400000);
        
        if (diffDays === 1) {
            streak++;
        } else {
            break;
        }
    }
    
    return streak;
};

const calculateEngagementScore = (checkIns, assignmentCompletion, messages) => {
    const checkInScore = Math.min((checkIns / 30) * 40, 40);
    const assignmentScore = (parseFloat(assignmentCompletion) / 100) * 30;
    const messageScore = Math.min((messages / 10) * 30, 30);
    
    return Math.round(checkInScore + assignmentScore + messageScore);
};

const calculateStats = (checkIns) => {
    if (checkIns.length === 0) return { avgMood: 0, avgCravings: 0, avgAnxiety: 0, avgSleep: 0 };
    
    return {
        avgMood: (checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length).toFixed(1),
        avgCravings: (checkIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / checkIns.length).toFixed(1),
        avgAnxiety: (checkIns.reduce((sum, c) => sum + (c.morningData?.anxietyLevel || 0), 0) / checkIns.length).toFixed(1),
        avgSleep: (checkIns.reduce((sum, c) => sum + (c.morningData?.sleepQuality || 0), 0) / checkIns.length).toFixed(1)
    };
};

const getSobrietyMilestones = async (start, end) => {
    const pirsSnap = await db.collection('users')
        .where('role', '==', 'pir')
        .get();

    const milestones = [];
    const milestonesDays = [7, 30, 60, 90, 180, 365];

    for (const pirDoc of pirsSnap.docs) {
        const pirData = pirDoc.data();
        if (!pirData.sobrietyDate) continue;

        const sobrietyDate = new Date(pirData.sobrietyDate);
        
        milestonesDays.forEach(days => {
            const milestoneDate = new Date(sobrietyDate);
            milestoneDate.setDate(milestoneDate.getDate() + days);
            
            if (milestoneDate >= start && milestoneDate <= end) {
                milestones.push({
                    pirName: pirData.displayName || pirData.email,
                    days,
                    achievedAt: milestoneDate,
                    title: `${days} Days Sober`
                });
            }
        });
    }

    return milestones;
};

const calculatePredictiveRisk = (checkIns, patterns, pirData) => {
    let score = 0;

    if (checkIns.length === 0) return 5;

    const avgMood = checkIns.reduce((sum, c) => sum + (c.morningData?.mood || 0), 0) / checkIns.length;
    const avgCravings = checkIns.reduce((sum, c) => sum + (c.morningData?.craving || 0), 0) / checkIns.length;

    if (avgMood <= 4) score += 3;
    if (avgCravings >= 6) score += 3;
    
    score += patterns.length;

    const sobrietyDays = pirData.sobrietyDate 
        ? Math.floor((new Date() - new Date(pirData.sobrietyDate)) / 86400000)
        : 0;
    
    if (sobrietyDays < 30) score += 2;

    return Math.min(score, 10);
};

const generateRecommendations = (patterns, riskScore) => {
    const recs = [];

    if (riskScore >= 7) {
        recs.push('Immediate check-in recommended');
        recs.push('Consider increasing session frequency');
    }

    if (patterns.includes('Declining mood trend')) {
        recs.push('Mood intervention activities');
    }

    if (patterns.includes('Increasing cravings')) {
        recs.push('Craving management resources');
        recs.push('Emergency support contacts review');
    }

    if (patterns.includes('Persistent high anxiety')) {
        recs.push('Anxiety coping techniques');
    }

    if (patterns.includes('Poor sleep quality')) {
        recs.push('Sleep hygiene education');
    }

    if (recs.length === 0) {
        recs.push('Continue current support plan');
    }

    return recs;
};
 // ==========================================
// CHART RENDERING + HANDLERS + PDF EXPORT
// Complete replacement section
// ==========================================

// ========== PROFESSIONAL CHART RENDERING ==========
const renderCharts = () => {
    // Destroy existing charts
    Object.values(chartInstances.current).forEach(chart => {
        if (chart) chart.destroy();
    });

    const data = reportData;
    const newCharts = {};

    // ========== MOOD & CRAVINGS CORRELATION (LINE CHART) ==========
    if (data.charts?.trends && chartRefs.moodVsCravings.current) {
        const ctx = chartRefs.moodVsCravings.current.getContext('2d');
        newCharts.moodVsCravings = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [
                    {
                        label: 'Mood',
                        data: data.charts.trends.moods,
                        borderColor: '#00A86B',
                        backgroundColor: 'rgba(76, 175, 80, 0.1)',
                        borderWidth: 3,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: '#00A86B',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    },
                    {
                        label: 'Cravings',
                        data: data.charts.trends.cravings,
                        borderColor: '#f44336',
                        backgroundColor: 'rgba(244, 67, 54, 0.1)',
                        borderWidth: 3,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: '#f44336',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Mood & Cravings Correlation',
                        font: { size: 16, weight: 'bold' },
                        padding: 15
                    },
                    subtitle: {
                        display: true,
                        text: 'Notice how these metrics relate to each other over time',
                        font: { size: 12 },
                        color: '#666',
                        padding: { bottom: 15 }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 13 }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        padding: 12,
                        titleFont: { size: 13, weight: 'bold' },
                        bodyFont: { size: 12 },
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + '/10';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: { size: 13, weight: 'bold' }
                        },
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Level (0-10)',
                            font: { size: 13, weight: 'bold' }
                        },
                        min: 0,
                        max: 10,
                        ticks: {
                            stepSize: 1
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.08)'
                        }
                    }
                }
            }
        });
    }

    // ========== ANXIETY & SLEEP CORRELATION (LINE CHART) ==========
    if (data.charts?.trends && chartRefs.anxietyVsSleep.current) {
        const ctx = chartRefs.anxietyVsSleep.current.getContext('2d');
        newCharts.anxietyVsSleep = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [
                    {
                        label: 'Anxiety',
                        data: data.charts.trends.anxiety,
                        borderColor: '#FF9800',
                        backgroundColor: 'rgba(255, 152, 0, 0.1)',
                        borderWidth: 3,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: '#FF9800',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    },
                    {
                        label: 'Sleep Quality',
                        data: data.charts.trends.sleep,
                        borderColor: '#9C27B0',
                        backgroundColor: 'rgba(156, 39, 176, 0.1)',
                        borderWidth: 3,
                        tension: 0.4,
                        fill: false,
                        pointRadius: 5,
                        pointHoverRadius: 7,
                        pointBackgroundColor: '#9C27B0',
                        pointBorderColor: '#fff',
                        pointBorderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Anxiety & Sleep Quality Correlation',
                        font: { size: 16, weight: 'bold' },
                        padding: 15
                    },
                    subtitle: {
                        display: true,
                        text: 'See how anxiety levels affect your sleep quality',
                        font: { size: 12 },
                        color: '#666',
                        padding: { bottom: 15 }
                    },
                    legend: {
                        display: true,
                        position: 'top',
                        labels: {
                            usePointStyle: true,
                            padding: 15,
                            font: { size: 13 }
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.8)',
                        padding: 12,
                        titleFont: { size: 13, weight: 'bold' },
                        bodyFont: { size: 12 },
                        callbacks: {
                            label: function(context) {
                                return context.dataset.label + ': ' + context.parsed.y + '/10';
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Date',
                            font: { size: 13, weight: 'bold' }
                        },
                        grid: {
                            display: false
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: 'Level (0-10)',
                            font: { size: 13, weight: 'bold' }
                        },
                        min: 0,
                        max: 10,
                        ticks: {
                            stepSize: 1
                        },
                        grid: {
                            color: 'rgba(0,0,0,0.08)'
                        }
                    }
                }
            }
        });
    }

    // ========== MOOD DISTRIBUTION (COLOR-CODED BAR CHART) ==========
    if (data.charts?.distribution && chartRefs.moodDistribution.current) {
        const ctx = chartRefs.moodDistribution.current.getContext('2d');
        newCharts.moodDistribution = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
                datasets: [{
                    label: 'Days at this mood level',
                    data: data.charts.distribution,
                    backgroundColor: [
                        '#f44336', '#f44336', '#f44336', // 1-3: Red (Concerning)
                        '#FF9800', '#FF9800', '#FF9800', // 4-6: Orange (Moderate)
                        '#00A86B', '#00A86B', '#00A86B', '#00A86B' // 7-10: Green (Healthy)
                    ],
                    borderColor: '#fff',
                    borderWidth: 2,
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Mood Distribution - Where You Spend Your Time',
                        font: { size: 16, weight: 'bold' },
                        padding: 15
                    },
                    subtitle: {
                        display: true,
                        text: 'Red (1-3): Needs Support | Orange (4-6): Moderate | Green (7-10): Healthy',
                        font: { size: 11 },
                        color: '#666',
                        padding: { bottom: 15 }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'Number of Days',
                            font: { size: 13, weight: 'bold' }
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'â† Low Mood â€” MOOD SCALE â€” High Mood â†’',
                            font: { size: 13, weight: 'bold' }
                        }
                    }
                }
            }
        });
    }

    // ========== MOOD TREND (SINGLE LINE) ==========
    if (data.charts?.trends && chartRefs.moodTrend.current) {
        const ctx = chartRefs.moodTrend.current.getContext('2d');
        newCharts.moodTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [{
                    label: 'Average Mood',
                    data: data.charts.trends.moods,
                    borderColor: '#00A86B',
                    backgroundColor: 'rgba(76, 175, 80, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: '#00A86B',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Daily Mood Trend',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        max: 10,
                        title: { display: true, text: 'Mood Level (0-10)', font: { weight: 'bold' } }
                    },
                    x: {
                        title: { display: true, text: 'Date', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== CRAVING TREND (SINGLE LINE) ==========
    if (data.charts?.trends && chartRefs.cravingTrend.current) {
        const ctx = chartRefs.cravingTrend.current.getContext('2d');
        newCharts.cravingTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [{
                    label: 'Average Cravings',
                    data: data.charts.trends.cravings,
                    borderColor: '#f44336',
                    backgroundColor: 'rgba(244, 67, 54, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: '#f44336',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Daily Cravings Trend',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        max: 10,
                        title: { display: true, text: 'Craving Level (0-10)', font: { weight: 'bold' } }
                    },
                    x: {
                        title: { display: true, text: 'Date', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== ANXIETY TREND (SINGLE LINE) ==========
    if (data.charts?.trends && chartRefs.anxietyTrend.current) {
        const ctx = chartRefs.anxietyTrend.current.getContext('2d');
        newCharts.anxietyTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [{
                    label: 'Average Anxiety',
                    data: data.charts.trends.anxiety,
                    borderColor: '#FF9800',
                    backgroundColor: 'rgba(255, 152, 0, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: '#FF9800',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Daily Anxiety Trend',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        max: 10,
                        title: { display: true, text: 'Anxiety Level (0-10)', font: { weight: 'bold' } }
                    },
                    x: {
                        title: { display: true, text: 'Date', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== SLEEP TREND (SINGLE LINE) ==========
    if (data.charts?.trends && chartRefs.sleepTrend.current) {
        const ctx = chartRefs.sleepTrend.current.getContext('2d');
        newCharts.sleepTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [{
                    label: 'Average Sleep Quality',
                    data: data.charts.trends.sleep,
                    borderColor: '#9C27B0',
                    backgroundColor: 'rgba(156, 39, 176, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: '#9C27B0',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Daily Sleep Quality Trend',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        max: 10,
                        title: { display: true, text: 'Sleep Quality (0-10)', font: { weight: 'bold' } }
                    },
                    x: {
                        title: { display: true, text: 'Date', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== ENGAGEMENT DISTRIBUTION ==========
    if (data.charts?.engagementDistribution && chartRefs.engagementChart.current) {
        const ctx = chartRefs.engagementChart.current.getContext('2d');
        newCharts.engagementChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.charts.engagementDistribution.labels,
                datasets: [{
                    label: 'Engagement Score',
                    data: data.charts.engagementDistribution.data,
                    backgroundColor: data.charts.engagementDistribution.data.map(score => 
                        score >= 75 ? '#00A86B' : score >= 50 ? '#FF9800' : '#f44336'
                    ),
                    borderColor: '#fff',
                    borderWidth: 2,
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                indexAxis: 'y',
                plugins: {
                    title: {
                        display: true,
                        text: 'PIR Engagement Scores',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    x: { 
                        beginAtZero: true, 
                        max: 100,
                        title: { display: true, text: 'Engagement Score (%)', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== EVENING REFLECTIONS - OVERALL DAY TREND ==========
    if (data.charts?.trends?.overallDayScores && chartRefs.overallDayTrend.current) {
        const ctx = chartRefs.overallDayTrend.current.getContext('2d');
        newCharts.overallDayTrend = new Chart(ctx, {
            type: 'line',
            data: {
                labels: data.charts.trends.dates,
                datasets: [{
                    label: 'Overall Day Rating',
                    data: data.charts.trends.overallDayScores,
                    borderColor: '#0077CC',
                    backgroundColor: 'rgba(102, 126, 234, 0.1)',
                    borderWidth: 3,
                    tension: 0.4,
                    fill: true,
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointBackgroundColor: '#0077CC',
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Daily Overall Day Rating',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true, 
                        max: 10,
                        title: { display: true, text: 'Overall Day (0-10)', font: { weight: 'bold' } }
                    },
                    x: {
                        title: { display: true, text: 'Date', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== EVENING REFLECTIONS - DAY QUALITY PIE CHART ==========
    if (data.charts?.dayQualityDistribution && chartRefs.dayQualityPie.current) {
        const ctx = chartRefs.dayQualityPie.current.getContext('2d');
        newCharts.dayQualityPie = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: data.charts.dayQualityDistribution.labels,
                datasets: [{
                    data: data.charts.dayQualityDistribution.data,
                    backgroundColor: ['#00A86B', '#FF9800', '#f44336'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Day Quality Distribution',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { 
                        display: true, 
                        position: 'bottom',
                        labels: {
                            padding: 15,
                            font: { size: 12 }
                        }
                    }
                }
            }
        });
    }

    // ========== EVENING REFLECTIONS - COMPLETION BREAKDOWN ==========
    if (data.charts?.completionBreakdown && chartRefs.completionBar.current) {
        const ctx = chartRefs.completionBar.current.getContext('2d');
        newCharts.completionBar = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: data.charts.completionBreakdown.labels,
                datasets: [{
                    label: 'Completed',
                    data: data.charts.completionBreakdown.data,
                    backgroundColor: ['#00A86B', '#FF9800', '#0077CC'],
                    borderColor: '#fff',
                    borderWidth: 2,
                    borderRadius: 6
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: 'Reflection Component Completion',
                        font: { size: 16, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    y: { 
                        beginAtZero: true,
                        title: { display: true, text: 'Number of Entries', font: { weight: 'bold' } }
                    }
                }
            }
        });
    }

    // ========== RISK DISTRIBUTION DOUGHNUT ==========
    if (data.charts?.riskDistribution && chartRefs.riskDistribution.current) {
        const ctx = chartRefs.riskDistribution.current.getContext('2d');
        newCharts.riskDistribution = new Chart(ctx, {
            type: 'doughnut',
            data: {
                labels: data.charts.riskDistribution.labels,
                datasets: [{
                    data: data.charts.riskDistribution.data,
                    backgroundColor: ['#00A86B', '#FF9800', '#f44336'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true, 
                        position: 'bottom',
                        labels: {
                            padding: 15,
                            font: { size: 12 }
                        }
                    }
                }
            }
        });
    }

    // ========== SOBRIETY VS CRAVINGS SCATTER ==========
    if (data.charts?.sobrietyVsCravings && chartRefs.sobrietyVsCravings.current) {
        const ctx = chartRefs.sobrietyVsCravings.current.getContext('2d');
        newCharts.sobrietyVsCravings = new Chart(ctx, {
            type: 'scatter',
            data: {
                datasets: [{
                    label: 'Days Sober vs Cravings',
                    data: data.charts.sobrietyVsCravings.data,
                    backgroundColor: 'rgba(76, 175, 80, 0.6)',
                    borderColor: '#00A86B',
                    pointRadius: 5,
                    pointHoverRadius: 7
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: true, position: 'top' }
                },
                scales: {
                    x: { 
                        title: { display: true, text: 'Days Sober' },
                        beginAtZero: true
                    },
                    y: { 
                        title: { display: true, text: 'Average Cravings' }, 
                        min: 0, 
                        max: 10 
                    }
                }
            }
        });
    }

    // ========== GOAL COMPLETION PIE CHART ==========
    if (data.charts?.goalCompletion && chartRefs.goalCompletion.current) {
        const ctx = chartRefs.goalCompletion.current.getContext('2d');
        newCharts.goalCompletion = new Chart(ctx, {
            type: 'pie',
            data: {
                labels: data.charts.goalCompletion.labels,
                datasets: [{
                    data: data.charts.goalCompletion.data,
                    backgroundColor: ['#0077CC', '#00A86B'],
                    borderWidth: 2,
                    borderColor: '#fff'
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { 
                        display: true, 
                        position: 'bottom',
                        labels: {
                            padding: 15,
                            font: { size: 12 }
                        }
                    }
                }
            }
        });
    }

    chartInstances.current = newCharts;
};

// ========== PDF EXPORT ==========
const exportReportToPDF = async (data, reportTitle) => {
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    let yPos = 20;

    // Title
    doc.setFontSize(20);
    doc.setTextColor(102, 126, 234);
    doc.text(reportTitle, 20, yPos);
    yPos += 10;

    // Metadata
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 20, yPos);
    yPos += 5;
    doc.text(`Date Range: ${startDate} to ${endDate}`, 20, yPos);
    yPos += 15;

    // Summary
    if (data.summary) {
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 0);
        doc.text('Summary Statistics', 20, yPos);
        yPos += 8;

        doc.setFontSize(10);
        Object.entries(data.summary).forEach(([key, value]) => {
            const label = key.replace(/([A-Z])/g, ' $1').trim();
            doc.text(`${label}: ${value}`, 30, yPos);
            yPos += 6;
            if (yPos > 270) {
                doc.addPage();
                yPos = 20;
            }
        });
        yPos += 10;
    }

    // Patterns
    if (data.patterns && data.patterns.length > 0) {
        if (yPos > 250) {
            doc.addPage();
            yPos = 20;
        }
        
        doc.setFontSize(14);
        doc.text('Detected Patterns', 20, yPos);
        yPos += 8;
        
        doc.setFontSize(10);
        data.patterns.forEach(pattern => {
            doc.text(`â€¢ ${pattern.message}`, 30, yPos);
            yPos += 6;
        });
        yPos += 10;
    }

    // Charts
    for (const [chartName, chartInstance] of Object.entries(chartInstances.current)) {
        if (chartInstance) {
            if (yPos > 200) {
                doc.addPage();
                yPos = 20;
            }

            doc.setFontSize(12);
            const chartTitle = chartName.replace(/([A-Z])/g, ' $1').trim();
            doc.text(chartTitle.charAt(0).toUpperCase() + chartTitle.slice(1), 20, yPos);
            yPos += 5;

            try {
                const chartImage = chartInstance.toBase64Image();
                doc.addImage(chartImage, 'PNG', 20, yPos, 170, 80);
                yPos += 90;
            } catch (error) {
                console.error('Error adding chart:', error);
            }
        }
    }

    // Data Tables
    if (data.sobrietyData) {
        if (yPos > 200) {
            doc.addPage();
            yPos = 20;
        }

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Days Sober', 'Avg Mood', 'Avg Cravings', 'Risk Level']],
            body: data.sobrietyData.map(p => [
                p.pirName,
                p.daysSober,
                p.avgMood,
                p.avgCravings,
                p.riskLevel
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    if (data.morningData) {
        doc.addPage();
        yPos = 20;

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Date', 'Mood', 'Craving', 'Anxiety', 'Sleep']],
            body: data.morningData.slice(0, 20).map(m => [
                m.pirName,
                formatDate(m.date),
                m.mood,
                m.craving,
                m.anxiety,
                m.sleep
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    if (data.eveningData) {
        doc.addPage();
        yPos = 20;

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Date', 'Overall Day', 'Gratitude', 'Challenges']],
            body: data.eveningData.slice(0, 20).map(e => [
                e.pirName,
                formatDate(e.date),
                e.overallDay + '/10',
                (e.gratitude || '').substring(0, 30) + '...',
                (e.challenges || '').substring(0, 30) + '...'
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    if (data.engagementData) {
        doc.addPage();
        yPos = 20;

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Check-ins', 'Streak', 'Messages', 'Score']],
            body: data.engagementData.slice(0, 20).map(e => [
                e.pirName,
                e.checkInCount,
                e.checkInStreak + ' days',
                e.messageCount,
                e.engagementScore
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    if (data.riskData) {
        doc.addPage();
        yPos = 20;

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Risk Score', 'Level', 'Patterns']],
            body: data.riskData.slice(0, 20).map(r => [
                r.pirName,
                r.riskScore + '/10',
                r.riskLevel,
                r.patterns.join(', ').substring(0, 40) + '...'
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    if (data.alerts) {
        doc.addPage();
        yPos = 20;

        doc.autoTable({
            startY: yPos,
            head: [['PIR', 'Type', 'Priority', 'Status', 'Created']],
            body: data.alerts.slice(0, 20).map(a => [
                a.pirName,
                a.type,
                a.priority || 'normal',
                a.resolved ? 'Resolved' : 'Active',
                formatTimeAgo(a.createdAt)
            ]),
            theme: 'striped',
            headStyles: { fillColor: [102, 126, 234] }
        });
    }

    doc.save(`${reportTitle.replace(/\s+/g, '_')}_${startDate}_to_${endDate}.pdf`);
};
  // ========== EXPORT REPORT TO PDF WITH CHARTS (RETURN BLOB) ==========
const exportReportToPDFBlob = async (data, reportTitle) => {
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // âœ… HELPER: Strip emojis from text
    const stripEmojis = (text) => {
        return text.replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu, '').trim();
    };
    
    // âœ… HELPER: Render chart to canvas and return base64
    const renderChartToImage = async (chartData, chartType, title) => {
        return new Promise((resolve) => {
            const canvas = document.createElement('canvas');
            canvas.width = 800;
            canvas.height = 400;
            document.body.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const chart = new Chart(ctx, {
                type: chartType,
                data: chartData,
                options: {
                    responsive: false,
                    animation: false,
                    plugins: {
                        title: {
                            display: true,
                            text: title,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
            
            setTimeout(() => {
                const imageData = canvas.toDataURL('image/png');
                chart.destroy();
                document.body.removeChild(canvas);
                resolve(imageData);
            }, 500);
        });
    };
    
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    let yPos = 20;

    // Title
    doc.setFontSize(20);
    doc.setTextColor(102, 126, 234);
    doc.text(reportTitle, 20, yPos);
    yPos += 10;

    // Metadata
    doc.setFontSize(10);
    doc.setTextColor(100, 100, 100);
    doc.text(`Generated: ${new Date().toLocaleString()}`, 20, yPos);
    yPos += 5;
    if (data.metadata?.period) {
        doc.text(`Period: ${data.metadata.period}`, 20, yPos);
        yPos += 15;
    } else {
        yPos += 10;
    }

    // Summary
    if (data.summary) {
        doc.setFontSize(14);
        doc.setTextColor(0, 0, 0);
        doc.text('Summary Statistics', 20, yPos);
        yPos += 8;

        doc.setFontSize(10);
        Object.entries(data.summary).forEach(([key, value]) => {
            const label = key.replace(/([A-Z])/g, ' $1').trim();
            doc.text(`${label}: ${value}`, 30, yPos);
            yPos += 6;
            if (yPos > 270) {
                doc.addPage();
                yPos = 20;
            }
        });
        yPos += 10;
    }

    // Insights
    if (data.insights && data.insights.length > 0) {
        if (yPos > 250) {
            doc.addPage();
            yPos = 20;
        }
        
        doc.setFontSize(14);
        doc.text('Key Insights', 20, yPos);
        yPos += 8;
        
        doc.setFontSize(10);
        data.insights.forEach(insight => {
            const cleanInsight = stripEmojis(insight);
            const lines = doc.splitTextToSize(cleanInsight, 170);
            lines.forEach(line => {
                doc.text(`- ${line}`, 30, yPos);
                yPos += 6;
                if (yPos > 270) {
                    doc.addPage();
                    yPos = 20;
                }
            });
        });
        yPos += 10;
    }

    // Patterns
    if (data.patterns && data.patterns.length > 0) {
        if (yPos > 250) {
            doc.addPage();
            yPos = 20;
        }
        
        doc.setFontSize(14);
        doc.text('Detected Patterns', 20, yPos);
        yPos += 8;
        
        doc.setFontSize(10);
        data.patterns.forEach(pattern => {
            const message = pattern.message || pattern;
            const cleanMessage = stripEmojis(message);
            const lines = doc.splitTextToSize(cleanMessage, 170);
            lines.forEach(line => {
                doc.text(`- ${line}`, 30, yPos);
                yPos += 6;
                if (yPos > 270) {
                    doc.addPage();

function ReportsApp() {
    const [searchQuery, setSearchQuery] = useState('');
    const [user, setUser] = useState(null);
    useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged(async (firebaseUser) => {
            if (firebaseUser) {
                const userDoc = await db.collection('users').doc(firebaseUser.uid).get();
                setUser({ uid: firebaseUser.uid, ...userDoc.data() });
            } else {
                window.location.href = '/';
            }
        });
        return unsubscribe;
    }, []);
    if (!user) {
        return <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: '100vh' }}><div className="loading-spinner"></div></div>;
    }
    return (
        <div style={{ display: 'flex', minHeight: '100vh' }}>
            <Sidebar activePage="reports" />
            <div style={{ flex: 1, marginLeft: '280px' }}>
                <Topbar user={user} searchQuery={searchQuery} onSearchChange={setSearchQuery} />
                <div style={{ padding: '20px' }}>
                    <ReportsView searchQuery={searchQuery} user={user} />
                </div>
            </div>
        </div>
    );
}
ReactDOM.render(<ReportsApp />, document.getElementById('root'));
})();
</script>
</body>
</html>
